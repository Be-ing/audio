/* automatically generated by rust-bindgen 0.58.1 */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const SPA_DIRECTION_INPUT: spa_direction = 0;
pub const SPA_DIRECTION_OUTPUT: spa_direction = 1;
pub type spa_direction = ::std::os::raw::c_uint;
#[repr(C)]
pub struct spa_rectangle {
    pub width: u32,
    pub height: u32,
}
#[repr(C)]
pub struct spa_point {
    pub x: i32,
    pub y: i32,
}
#[repr(C)]
pub struct spa_region {
    pub position: spa_point,
    pub size: spa_rectangle,
}
#[repr(C)]
pub struct spa_fraction {
    pub num: u32,
    pub denom: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_dict_item {
    pub key: *const ::std::os::raw::c_char,
    pub value: *const ::std::os::raw::c_char,
}
#[repr(C)]
pub struct spa_dict {
    pub flags: u32,
    pub n_items: u32,
    pub items: *const spa_dict_item,
}
#[repr(C)]
pub struct spa_handle {
    pub version: u32,
    #[doc = " Get the interface provided by \\a handle with \\a type."]
    #[doc = ""]
    #[doc = " \\a interface is always a struct spa_interface but depending on"]
    #[doc = " \\a type, the struct might contain other information."]
    #[doc = ""]
    #[doc = " \\param handle a spa_handle"]
    #[doc = " \\param type the interface type"]
    #[doc = " \\param interface result to hold the interface."]
    #[doc = " \\return 0 on success"]
    #[doc = "         -ENOTSUP when there are no interfaces"]
    #[doc = "         -EINVAL when handle or info is NULL"]
    pub get_interface: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut spa_handle,
            type_: *const ::std::os::raw::c_char,
            interface: *mut *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Clean up the memory of \\a handle. After this, \\a handle should not be used"]
    #[doc = " anymore."]
    #[doc = ""]
    #[doc = " \\param handle a pointer to memory"]
    #[doc = " \\return 0 on success"]
    pub clear: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut spa_handle) -> ::std::os::raw::c_int,
    >,
}
#[doc = " This structure lists the information about available interfaces on"]
#[doc = " handles."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_interface_info {
    pub type_: *const ::std::os::raw::c_char,
}
#[doc = " Extra supporting infrastructure passed to the init() function of"]
#[doc = " a factory. It can be extra information or interfaces such as logging."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_support {
    pub type_: *const ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
pub struct spa_handle_factory {
    pub version: u32,
    #[doc = " The name of the factory contains a logical name that describes"]
    #[doc = " the function of the handle. Other plugins might contain an alternative"]
    #[doc = " implementation with the same name."]
    #[doc = ""]
    #[doc = " See utils/names.h for the list of standard names."]
    #[doc = ""]
    #[doc = " Examples include:"]
    #[doc = ""]
    #[doc = "  api.alsa.pcm.sink: an object to write PCM samples to an alsa PLAYBACK"]
    #[doc = "\t\t\tdevice"]
    #[doc = "  api.v4l2.source: an object to read from a v4l2 source."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Extra information about the handles of this factory."]
    pub info: *const spa_dict,
    #[doc = " Get the size of handles from this factory."]
    #[doc = ""]
    #[doc = " \\param factory a spa_handle_factory"]
    #[doc = " \\param params extra parameters that determine the size of the"]
    #[doc = " handle."]
    pub get_size: ::std::option::Option<
        unsafe extern "C" fn(factory: *const spa_handle_factory, params: *const spa_dict) -> usize,
    >,
    #[doc = " Initialize an instance of this factory. The caller should allocate"]
    #[doc = " memory at least size bytes and pass this as \\a handle."]
    #[doc = ""]
    #[doc = " \\a support can optionally contain extra interfaces or data items that the"]
    #[doc = " plugin can use such as a logger."]
    #[doc = ""]
    #[doc = " \\param factory a spa_handle_factory"]
    #[doc = " \\param handle a pointer to memory"]
    #[doc = " \\param info extra handle specific information, usually obtained"]
    #[doc = "        from a spa_device. This can be used to configure the handle."]
    #[doc = " \\param support support items"]
    #[doc = " \\param n_support number of elements in \\a support"]
    #[doc = " \\return 0 on success"]
    #[doc = "\t   < 0 errno type error"]
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            factory: *const spa_handle_factory,
            handle: *mut spa_handle,
            info: *const spa_dict,
            support: *const spa_support,
            n_support: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " spa_handle_factory::enum_interface_info:"]
    #[doc = " \\param factory: a #spa_handle_factory"]
    #[doc = " \\param info: result to hold spa_interface_info."]
    #[doc = " \\param index: index to keep track of the enumeration, 0 for first item"]
    #[doc = ""]
    #[doc = " Enumerate the interface information for \\a factory."]
    #[doc = ""]
    #[doc = " \\return 1 when an item is available"]
    #[doc = "\t   0 when no more items are available"]
    #[doc = "\t   < 0 errno type error"]
    pub enum_interface_info: ::std::option::Option<
        unsafe extern "C" fn(
            factory: *const spa_handle_factory,
            info: *mut *const spa_interface_info,
            index: *mut u32,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = " The function signature of the entry point in a plugin."]
#[doc = ""]
#[doc = " \\param factory a location to hold the factory result"]
#[doc = " \\param index index to keep track of the enumeration"]
#[doc = " \\return 1 on success"]
#[doc = "         0 when there are no more factories"]
#[doc = "         -EINVAL when factory is NULL"]
pub type spa_handle_factory_enum_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        factory: *mut *const spa_handle_factory,
        index: *mut u32,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " The entry point in a plugin."]
    #[doc = ""]
    #[doc = " \\param factory a location to hold the factory result"]
    #[doc = " \\param index index to keep track of the enumeration"]
    #[doc = " \\return 1 on success"]
    #[doc = "\t   0 when no more items are available"]
    #[doc = "\t   < 0 errno type error"]
    pub fn spa_handle_factory_enum(
        factory: *mut *const spa_handle_factory,
        index: *mut u32,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\class pw_array"]
#[doc = ""]
#[doc = " \\brief An array object"]
#[doc = ""]
#[doc = " The array is a dynamically resizable data structure that can"]
#[doc = " hold items of the same size."]
#[repr(C)]
pub struct pw_array {
    #[doc = "< pointer to array data"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< length of array in bytes"]
    pub size: usize,
    #[doc = "< number of allocated memory in \\a data"]
    pub alloc: usize,
    #[doc = "< number of bytes to extend with"]
    pub extend: usize,
}
#[doc = "< invalid"]
pub const SPA_PARAM_Invalid: spa_param_type = 0;
#[doc = "< property information as SPA_TYPE_OBJECT_PropInfo"]
pub const SPA_PARAM_PropInfo: spa_param_type = 1;
#[doc = "< properties as SPA_TYPE_OBJECT_Props"]
pub const SPA_PARAM_Props: spa_param_type = 2;
#[doc = "< available formats as SPA_TYPE_OBJECT_Format"]
pub const SPA_PARAM_EnumFormat: spa_param_type = 3;
#[doc = "< configured format as SPA_TYPE_OBJECT_Format"]
pub const SPA_PARAM_Format: spa_param_type = 4;
#[doc = "< buffer configurations as SPA_TYPE_OBJECT_ParamBuffers"]
pub const SPA_PARAM_Buffers: spa_param_type = 5;
#[doc = "< allowed metadata for buffers as SPA_TYPE_OBJECT_ParamMeta"]
pub const SPA_PARAM_Meta: spa_param_type = 6;
#[doc = "< configurable IO areas as SPA_TYPE_OBJECT_ParamIO"]
pub const SPA_PARAM_IO: spa_param_type = 7;
#[doc = "< profile enumeration as SPA_TYPE_OBJECT_ParamProfile"]
pub const SPA_PARAM_EnumProfile: spa_param_type = 8;
#[doc = "< profile configuration as SPA_TYPE_OBJECT_ParamProfile"]
pub const SPA_PARAM_Profile: spa_param_type = 9;
#[doc = "< port configuration enumeration as SPA_TYPE_OBJECT_ParamPortConfig"]
pub const SPA_PARAM_EnumPortConfig: spa_param_type = 10;
#[doc = "< port configuration as SPA_TYPE_OBJECT_ParamPortConfig"]
pub const SPA_PARAM_PortConfig: spa_param_type = 11;
#[doc = "< routing enumeration as SPA_TYPE_OBJECT_ParamRoute"]
pub const SPA_PARAM_EnumRoute: spa_param_type = 12;
#[doc = "< routing configuration as SPA_TYPE_OBJECT_ParamRoute"]
pub const SPA_PARAM_Route: spa_param_type = 13;
#[doc = "< Control parameter, a SPA_TYPE_Sequence"]
pub const SPA_PARAM_Control: spa_param_type = 14;
#[doc = " different parameter types that can be queried"]
pub type spa_param_type = ::std::os::raw::c_uint;
#[doc = " information about a parameter"]
#[repr(C)]
pub struct spa_param_info {
    #[doc = "< enum spa_param_type"]
    pub id: u32,
    pub flags: u32,
    #[doc = "< private user field. You can use this to keep"]
    #[doc = "  state."]
    pub user: u32,
    pub padding: [u32; 5usize],
}
pub const SPA_PARAM_BUFFERS_START: spa_param_buffers = 0;
#[doc = "< number of buffers (Int)"]
pub const SPA_PARAM_BUFFERS_buffers: spa_param_buffers = 1;
#[doc = "< number of data blocks per buffer (Int)"]
pub const SPA_PARAM_BUFFERS_blocks: spa_param_buffers = 2;
#[doc = "< size of a data block memory (Int)"]
pub const SPA_PARAM_BUFFERS_size: spa_param_buffers = 3;
#[doc = "< stride of data block memory (Int)"]
pub const SPA_PARAM_BUFFERS_stride: spa_param_buffers = 4;
#[doc = "< alignment of data block memory (Int)"]
pub const SPA_PARAM_BUFFERS_align: spa_param_buffers = 5;
#[doc = "< possible memory types (Int, mask of enum spa_data_type)"]
pub const SPA_PARAM_BUFFERS_dataType: spa_param_buffers = 6;
#[doc = " properties for SPA_TYPE_OBJECT_ParamBuffers"]
pub type spa_param_buffers = ::std::os::raw::c_uint;
pub const SPA_PARAM_META_START: spa_param_meta = 0;
#[doc = "< the metadata, one of enum spa_meta_type (Id enum spa_meta_type)"]
pub const SPA_PARAM_META_type: spa_param_meta = 1;
#[doc = "< the expected maximum size the meta (Int)"]
pub const SPA_PARAM_META_size: spa_param_meta = 2;
#[doc = " properties for SPA_TYPE_OBJECT_ParamMeta"]
pub type spa_param_meta = ::std::os::raw::c_uint;
pub const SPA_PARAM_IO_START: spa_param_io = 0;
#[doc = "< type ID, uniquely identifies the io area (Id enum spa_io_type)"]
pub const SPA_PARAM_IO_id: spa_param_io = 1;
#[doc = "< size of the io area (Int)"]
pub const SPA_PARAM_IO_size: spa_param_io = 2;
#[doc = " properties for SPA_TYPE_OBJECT_ParamIO"]
pub type spa_param_io = ::std::os::raw::c_uint;
#[doc = "< unknown availability"]
pub const SPA_PARAM_AVAILABILITY_unknown: spa_param_availability = 0;
#[doc = "< not available"]
pub const SPA_PARAM_AVAILABILITY_no: spa_param_availability = 1;
#[doc = "< available"]
pub const SPA_PARAM_AVAILABILITY_yes: spa_param_availability = 2;
pub type spa_param_availability = ::std::os::raw::c_uint;
pub const SPA_PARAM_PROFILE_START: spa_param_profile = 0;
#[doc = "< profile index (Int)"]
pub const SPA_PARAM_PROFILE_index: spa_param_profile = 1;
#[doc = "< profile name (String)"]
pub const SPA_PARAM_PROFILE_name: spa_param_profile = 2;
#[doc = "< profile description (String)"]
pub const SPA_PARAM_PROFILE_description: spa_param_profile = 3;
#[doc = "< profile priority (Int)"]
pub const SPA_PARAM_PROFILE_priority: spa_param_profile = 4;
#[doc = "< availability of the profile"]
#[doc = "  (Id enum spa_param_availability)"]
pub const SPA_PARAM_PROFILE_available: spa_param_profile = 5;
#[doc = "< info (Struct("]
#[doc = "\t\t  Int : n_items,"]
#[doc = "\t\t  (String : key,"]
#[doc = "\t\t   String : value)*))"]
pub const SPA_PARAM_PROFILE_info: spa_param_profile = 6;
#[doc = "< node classes provided by this profile"]
#[doc = "  (Struct("]
#[doc = "\t   Int : number of items following"]
#[doc = "        Struct("]
#[doc = "           String : class name (eg. \"Audio/Source\"),"]
#[doc = "           Int : number of nodes"]
#[doc = "           String : property (eg. \"card.profile.devices\"),"]
#[doc = "           Array of Int: device indexes"]
#[doc = "         )*))"]
pub const SPA_PARAM_PROFILE_classes: spa_param_profile = 7;
#[doc = "< If profile should be saved (Bool)"]
pub const SPA_PARAM_PROFILE_save: spa_param_profile = 8;
#[doc = " properties for SPA_TYPE_OBJECT_ParamProfile"]
pub type spa_param_profile = ::std::os::raw::c_uint;
#[doc = "< no configuration"]
pub const SPA_PARAM_PORT_CONFIG_MODE_none: spa_param_port_config_mode = 0;
#[doc = "< passthrough configuration"]
pub const SPA_PARAM_PORT_CONFIG_MODE_passthrough: spa_param_port_config_mode = 1;
#[doc = "< convert configuration"]
pub const SPA_PARAM_PORT_CONFIG_MODE_convert: spa_param_port_config_mode = 2;
#[doc = "< dsp configuration, depending on the external"]
#[doc = "  format. For audio, ports will be configured for"]
#[doc = "  the given number of channels with F32 format."]
pub const SPA_PARAM_PORT_CONFIG_MODE_dsp: spa_param_port_config_mode = 3;
pub type spa_param_port_config_mode = ::std::os::raw::c_uint;
pub const SPA_PARAM_PORT_CONFIG_START: spa_param_port_config = 0;
#[doc = "< direction, input/output (Id enum spa_direction)"]
pub const SPA_PARAM_PORT_CONFIG_direction: spa_param_port_config = 1;
#[doc = "< (Id enum spa_param_port_config_mode) mode"]
pub const SPA_PARAM_PORT_CONFIG_mode: spa_param_port_config = 2;
#[doc = "< (Bool) enable monitor output ports on input ports"]
pub const SPA_PARAM_PORT_CONFIG_monitor: spa_param_port_config = 3;
#[doc = "< (Bool) enable control ports"]
pub const SPA_PARAM_PORT_CONFIG_control: spa_param_port_config = 4;
#[doc = "< (Object) format filter"]
pub const SPA_PARAM_PORT_CONFIG_format: spa_param_port_config = 5;
#[doc = " properties for SPA_TYPE_OBJECT_ParamPortConfig"]
pub type spa_param_port_config = ::std::os::raw::c_uint;
pub const SPA_PARAM_ROUTE_START: spa_param_route = 0;
#[doc = "< index of the routing destination (Int)"]
pub const SPA_PARAM_ROUTE_index: spa_param_route = 1;
#[doc = "< direction, input/output (Id enum spa_direction)"]
pub const SPA_PARAM_ROUTE_direction: spa_param_route = 2;
#[doc = "< device id (Int)"]
pub const SPA_PARAM_ROUTE_device: spa_param_route = 3;
#[doc = "< name of the routing destination (String)"]
pub const SPA_PARAM_ROUTE_name: spa_param_route = 4;
#[doc = "< description of the destination (String)"]
pub const SPA_PARAM_ROUTE_description: spa_param_route = 5;
#[doc = "< priority of the destination (Int)"]
pub const SPA_PARAM_ROUTE_priority: spa_param_route = 6;
#[doc = "< availability of the destination"]
#[doc = "  (Id enum spa_param_availability)"]
pub const SPA_PARAM_ROUTE_available: spa_param_route = 7;
#[doc = "< info (Struct("]
#[doc = "\t\t  Int : n_items,"]
#[doc = "\t\t  (String : key,"]
#[doc = "\t\t   String : value)*))"]
pub const SPA_PARAM_ROUTE_info: spa_param_route = 8;
#[doc = "< associated profile indexes (Array of Int)"]
pub const SPA_PARAM_ROUTE_profiles: spa_param_route = 9;
#[doc = "< properties SPA_TYPE_OBJECT_Props"]
pub const SPA_PARAM_ROUTE_props: spa_param_route = 10;
#[doc = "< associated device indexes (Array of Int)"]
pub const SPA_PARAM_ROUTE_devices: spa_param_route = 11;
#[doc = "< profile id (Int)"]
pub const SPA_PARAM_ROUTE_profile: spa_param_route = 12;
#[doc = "< If route should be saved (Bool)"]
pub const SPA_PARAM_ROUTE_save: spa_param_route = 13;
#[doc = " properties for SPA_TYPE_OBJECT_ParamRoute"]
pub type spa_param_route = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_list {
    pub next: *mut spa_list,
    pub prev: *mut spa_list,
}
#[doc = " \\class spa_hook"]
#[doc = ""]
#[doc = " \\brief a list of hooks"]
#[doc = ""]
#[doc = " The hook list provides a way to keep track of hooks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_hook_list {
    pub list: spa_list,
}
#[doc = " Callbacks, contains the structure with functions and the data passed"]
#[doc = " to the functions.  The structure should also contain a version field that"]
#[doc = " is checked."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_callbacks {
    pub funcs: *const ::std::os::raw::c_void,
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
pub struct spa_interface {
    pub type_: *const ::std::os::raw::c_char,
    pub version: u32,
    pub cb: spa_callbacks,
}
#[doc = " A hook, contains the structure with functions and the data passed"]
#[doc = " to the functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_hook {
    pub link: spa_list,
    pub cb: spa_callbacks,
    #[doc = " callback and data for the hook list, private to the"]
    #[doc = " hook_list implementor"]
    pub removed: ::std::option::Option<unsafe extern "C" fn(hook: *mut spa_hook)>,
    pub priv_: *mut ::std::os::raw::c_void,
}
#[doc = " \\class pw_proxy"]
#[doc = ""]
#[doc = " \\brief Represents an object on the client side."]
#[doc = ""]
#[doc = " A pw_proxy acts as a client side proxy to an object existing in a remote"]
#[doc = " pipewire instance. The proxy is responsible for converting interface functions"]
#[doc = " invoked by the client to PipeWire messages. Events will call the handlers"]
#[doc = " set in listener."]
#[doc = ""]
#[doc = " See \\ref page_proxy"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_proxy {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_protocol {
    _unused: [u8; 0],
}
#[doc = " \\class pw_context"]
#[doc = ""]
#[doc = " \\brief the PipeWire context"]
#[doc = ""]
#[doc = " The context object manages all locally available resources. It"]
#[doc = " is used by both clients and servers."]
#[doc = ""]
#[doc = " The context is used to:"]
#[doc = ""]
#[doc = "  - Load modules and extend the functionality. This includes"]
#[doc = "    extending the protocol with new object types or creating"]
#[doc = "    any of the available objects."]
#[doc = ""]
#[doc = "  - Create implementations of various objects like nodes,"]
#[doc = "    devices, factories, modules, etc.. This will usually also"]
#[doc = "    create pw_global objects that can then be shared with"]
#[doc = "    clients."]
#[doc = ""]
#[doc = "  - Connect to another PipeWire instance (the main daemon, for"]
#[doc = "    example) and interact with it (See \\subpage page_core_api)."]
#[doc = ""]
#[doc = "  - Export a local implementation of an object to another"]
#[doc = "    instance."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_global {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_client {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_core {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_registry {
    _unused: [u8; 0],
}
#[doc = "  The core information. Extra information can be added in later versions \\memberof pw_introspect"]
#[repr(C)]
pub struct pw_core_info {
    #[doc = "< id of the global"]
    pub id: u32,
    #[doc = "< a random cookie for identifying this instance of PipeWire"]
    pub cookie: u32,
    #[doc = "< name of the user that started the core"]
    pub user_name: *const ::std::os::raw::c_char,
    #[doc = "< name of the machine the core is running on"]
    pub host_name: *const ::std::os::raw::c_char,
    #[doc = "< version of the core"]
    pub version: *const ::std::os::raw::c_char,
    #[doc = "< name of the core"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< extra properties"]
    pub props: *mut spa_dict,
}
#[doc = " \\class pw_properties"]
#[doc = ""]
#[doc = " \\brief A collection of key/value pairs"]
#[doc = ""]
#[doc = " Properties are used to pass around arbitrary key/value pairs."]
#[doc = " Both keys and values are strings which keeps things simple."]
#[doc = " Encoding of arbitrary values should be done by using a string"]
#[doc = " serialization such as base64 for binary blobs."]
#[repr(C)]
pub struct pw_properties {
    #[doc = "< dictionary of key/values"]
    pub dict: spa_dict,
    #[doc = "< extra flags"]
    pub flags: u32,
}
extern "C" {
    pub fn pw_properties_new(key: *const ::std::os::raw::c_char, ...) -> *mut pw_properties;
}
extern "C" {
    pub fn pw_properties_new_dict(dict: *const spa_dict) -> *mut pw_properties;
}
extern "C" {
    pub fn pw_properties_new_string(args: *const ::std::os::raw::c_char) -> *mut pw_properties;
}
extern "C" {
    pub fn pw_properties_copy(properties: *const pw_properties) -> *mut pw_properties;
}
extern "C" {
    pub fn pw_properties_update_keys(
        props: *mut pw_properties,
        dict: *const spa_dict,
        keys: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pw_properties_update_ignore(
        props: *mut pw_properties,
        dict: *const spa_dict,
        ignore: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pw_properties_update(
        oldprops: *mut pw_properties,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pw_properties_update_string(
        props: *mut pw_properties,
        str_: *const ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pw_properties_add(
        oldprops: *mut pw_properties,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pw_properties_add_keys(
        oldprops: *mut pw_properties,
        dict: *const spa_dict,
        keys: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pw_properties_clear(properties: *mut pw_properties);
}
extern "C" {
    pub fn pw_properties_free(properties: *mut pw_properties);
}
extern "C" {
    pub fn pw_properties_set(
        properties: *mut pw_properties,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pw_properties_setf(
        properties: *mut pw_properties,
        key: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pw_properties_setva(
        properties: *mut pw_properties,
        key: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pw_properties_get(
        properties: *const pw_properties,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pw_properties_iterate(
        properties: *const pw_properties,
        state: *mut *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Update and existing \\ref pw_core_info with \\a update  \\memberof pw_introspect"]
    pub fn pw_core_info_update(
        info: *mut pw_core_info,
        update: *const pw_core_info,
    ) -> *mut pw_core_info;
}
extern "C" {
    #[doc = " Free a \\ref pw_core_info  \\memberof pw_introspect"]
    pub fn pw_core_info_free(info: *mut pw_core_info);
}
#[doc = " \\struct pw_core_events"]
#[doc = "  \\brief Core events"]
#[doc = "  \\ingroup pw_core_interface The pw_core interface"]
#[repr(C)]
pub struct pw_core_events {
    pub version: u32,
    #[doc = " Notify new core info"]
    #[doc = ""]
    #[doc = " This event is emitted when first bound to the core or when the"]
    #[doc = " hello method is called."]
    #[doc = ""]
    #[doc = " \\param info new core info"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void, info: *const pw_core_info),
    >,
    #[doc = " Emit a done event"]
    #[doc = ""]
    #[doc = " The done event is emitted as a result of a sync method with the"]
    #[doc = " same seq number."]
    #[doc = ""]
    #[doc = " \\param seq the seq number passed to the sync method call"]
    pub done: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            seq: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Emit a ping event"]
    #[doc = ""]
    #[doc = " The client should reply with a pong reply with the same seq"]
    #[doc = " number."]
    pub ping: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            seq: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Fatal error event"]
    #[doc = ""]
    #[doc = " The error event is sent out when a fatal (non-recoverable)"]
    #[doc = " error has occurred. The id argument is the proxy object where"]
    #[doc = " the error occurred, most often in response to a request to that"]
    #[doc = " object. The message is a brief description of the error,"]
    #[doc = " for (debugging) convenience."]
    #[doc = ""]
    #[doc = " This event is usually also emitted on the proxy object with"]
    #[doc = " \\a id."]
    #[doc = ""]
    #[doc = " \\param id object where the error occurred"]
    #[doc = " \\param seq the sequence number that generated the error"]
    #[doc = " \\param res error code"]
    #[doc = " \\param message error description"]
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            seq: ::std::os::raw::c_int,
            res: ::std::os::raw::c_int,
            message: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " Remove an object ID"]
    #[doc = ""]
    #[doc = " This event is used internally by the object ID management"]
    #[doc = " logic. When a client deletes an object, the server will send"]
    #[doc = " this event to acknowledge that it has seen the delete request."]
    #[doc = " When the client receives this event, it will know that it can"]
    #[doc = " safely reuse the object ID."]
    #[doc = ""]
    #[doc = " \\param id deleted object ID"]
    pub remove_id:
        ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void, id: u32)>,
    #[doc = " Notify an object binding"]
    #[doc = ""]
    #[doc = " This event is emitted when a local object ID is bound to a"]
    #[doc = " global ID. It is emitted before the global becomes visible in the"]
    #[doc = " registry."]
    #[doc = ""]
    #[doc = " \\param id bound object ID"]
    #[doc = " \\param global_id the global id bound to"]
    pub bound_id: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void, id: u32, global_id: u32),
    >,
    #[doc = " Add memory for a client"]
    #[doc = ""]
    #[doc = " Memory is given to a client as \\a fd of a certain"]
    #[doc = " memory \\a type."]
    #[doc = ""]
    #[doc = " Further references to this fd will be made with the per memory"]
    #[doc = " unique identifier \\a id."]
    #[doc = ""]
    #[doc = " \\param id the unique id of the memory"]
    #[doc = " \\param type the memory type, one of enum spa_data_type"]
    #[doc = " \\param fd the file descriptor"]
    #[doc = " \\param flags extra flags"]
    pub add_mem: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            type_: u32,
            fd: ::std::os::raw::c_int,
            flags: u32,
        ),
    >,
    #[doc = " Remove memory for a client"]
    #[doc = ""]
    #[doc = " \\param id the memory id to remove"]
    pub remove_mem:
        ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void, id: u32)>,
}
#[doc = " \\struct pw_core_methods"]
#[doc = " \\brief Core methods"]
#[doc = ""]
#[doc = " The core global object. This is a singleton object used for"]
#[doc = " creating new objects in the remote PipeWire instance. It is"]
#[doc = " also used for internal features."]
#[repr(C)]
pub struct pw_core_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_core_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Start a conversation with the server. This will send"]
    #[doc = " the core info and will destroy all resources for the client"]
    #[doc = " (except the core and client resource)."]
    pub hello: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            version: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Do server roundtrip"]
    #[doc = ""]
    #[doc = " Ask the server to emit the 'done' event with \\a seq."]
    #[doc = ""]
    #[doc = " Since methods are handled in-order and events are delivered"]
    #[doc = " in-order, this can be used as a barrier to ensure all previous"]
    #[doc = " methods and the resulting events have been handled."]
    #[doc = ""]
    #[doc = " \\param seq the seq number passed to the done event"]
    pub sync: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            seq: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Reply to a server ping event."]
    #[doc = ""]
    #[doc = " Reply to the server ping event with the same seq."]
    #[doc = ""]
    #[doc = " \\param seq the seq number received in the ping event"]
    pub pong: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            seq: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Fatal error event"]
    #[doc = ""]
    #[doc = " The error method is sent out when a fatal (non-recoverable)"]
    #[doc = " error has occurred. The id argument is the proxy object where"]
    #[doc = " the error occurred, most often in response to an event on that"]
    #[doc = " object. The message is a brief description of the error,"]
    #[doc = " for (debugging) convenience."]
    #[doc = ""]
    #[doc = " This method is usually also emitted on the resource object with"]
    #[doc = " \\a id."]
    #[doc = ""]
    #[doc = " \\param id object where the error occurred"]
    #[doc = " \\param res error code"]
    #[doc = " \\param message error description"]
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            seq: ::std::os::raw::c_int,
            res: ::std::os::raw::c_int,
            message: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Get the registry object"]
    #[doc = ""]
    #[doc = " Create a registry object that allows the client to list and bind"]
    #[doc = " the global objects available from the PipeWire server"]
    #[doc = " \\param version the client version"]
    #[doc = " \\param user_data_size extra size"]
    pub get_registry: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            version: u32,
            user_data_size: usize,
        ) -> *mut pw_registry,
    >,
    #[doc = " Create a new object on the PipeWire server from a factory."]
    #[doc = ""]
    #[doc = " \\param factory_name the factory name to use"]
    #[doc = " \\param type the interface to bind to"]
    #[doc = " \\param version the version of the interface"]
    #[doc = " \\param props extra properties"]
    #[doc = " \\param user_data_size extra size"]
    pub create_object: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            factory_name: *const ::std::os::raw::c_char,
            type_: *const ::std::os::raw::c_char,
            version: u32,
            props: *const spa_dict,
            user_data_size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Destroy an resource"]
    #[doc = ""]
    #[doc = " Destroy the server resource for the given proxy."]
    #[doc = ""]
    #[doc = " \\param obj the proxy to destroy"]
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            proxy: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = " Registry events"]
#[repr(C)]
pub struct pw_registry_events {
    pub version: u32,
    #[doc = " Notify of a new global object"]
    #[doc = ""]
    #[doc = " The registry emits this event when a new global object is"]
    #[doc = " available."]
    #[doc = ""]
    #[doc = " \\param id the global object id"]
    #[doc = " \\param permissions the permissions of the object"]
    #[doc = " \\param type the type of the interface"]
    #[doc = " \\param version the version of the interface"]
    #[doc = " \\param props extra properties of the global"]
    pub global: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            permissions: u32,
            type_: *const ::std::os::raw::c_char,
            version: u32,
            props: *const spa_dict,
        ),
    >,
    #[doc = " Notify of a global object removal"]
    #[doc = ""]
    #[doc = " Emitted when a global object was removed from the registry."]
    #[doc = " If the client has any bindings to the global, it should destroy"]
    #[doc = " those."]
    #[doc = ""]
    #[doc = " \\param id the id of the global that was removed"]
    pub global_remove:
        ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void, id: u32)>,
}
#[doc = " Registry methods"]
#[repr(C)]
pub struct pw_registry_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_registry_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Bind to a global object"]
    #[doc = ""]
    #[doc = " Bind to the global object with \\a id and use the client proxy"]
    #[doc = " with new_id as the proxy. After this call, methods can be"]
    #[doc = " send to the remote global object and events can be received"]
    #[doc = ""]
    #[doc = " \\param id the global id to bind to"]
    #[doc = " \\param type the interface type to bind to"]
    #[doc = " \\param version the interface version to use"]
    #[doc = " \\returns the new object"]
    pub bind: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            type_: *const ::std::os::raw::c_char,
            version: u32,
            use_data_size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Attempt to destroy a global object"]
    #[doc = ""]
    #[doc = " Try to destroy the global object."]
    #[doc = ""]
    #[doc = " \\param id the global id to destroy"]
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void, id: u32) -> ::std::os::raw::c_int,
    >,
}
extern "C" {
    #[doc = " Connect to a PipeWire instance \\memberof pw_core"]
    #[doc = " \\return a pw_core on success or NULL with errno set on error. The core"]
    #[doc = " will have an id of PW_ID_CORE (0)"]
    pub fn pw_context_connect(
        context: *mut pw_context,
        properties: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_core;
}
extern "C" {
    #[doc = " Connect to a PipeWire instance on the given socket \\memberof pw_core"]
    #[doc = " \\param fd the connected socket to use, the socket will be closed"]
    #[doc = "\tautomatically on disconnect or error."]
    #[doc = " \\return a pw_core on success or NULL with errno set on error"]
    pub fn pw_context_connect_fd(
        context: *mut pw_context,
        fd: ::std::os::raw::c_int,
        properties: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_core;
}
extern "C" {
    #[doc = " Connect to a given PipeWire instance \\memberof pw_core"]
    #[doc = " \\return a pw_core on success or NULL with errno set on error"]
    pub fn pw_context_connect_self(
        context: *mut pw_context,
        properties: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_core;
}
extern "C" {
    #[doc = " Steal the fd of the core connection or < 0 on error. The core"]
    #[doc = " will be disconnected after this call."]
    pub fn pw_core_steal_fd(core: *mut pw_core) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Pause or resume the core. When the core is paused, no new events"]
    #[doc = "  will be dispatched until the core is resumed again."]
    pub fn pw_core_set_paused(core: *mut pw_core, paused: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " disconnect and destroy a core"]
    pub fn pw_core_disconnect(core: *mut pw_core) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the user_data. It is of the size specified when this object was"]
    #[doc = " constructed"]
    pub fn pw_core_get_user_data(core: *mut pw_core) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get the client proxy of the connected core. This will have the id"]
    #[doc = " of PW_ID_CLIENT (1)"]
    pub fn pw_core_get_client(core: *mut pw_core) -> *mut pw_client;
}
extern "C" {
    #[doc = " Get the context object used to created this core"]
    pub fn pw_core_get_context(core: *mut pw_core) -> *mut pw_context;
}
extern "C" {
    #[doc = " Get properties from the core"]
    pub fn pw_core_get_properties(core: *mut pw_core) -> *const pw_properties;
}
extern "C" {
    #[doc = " Update the core properties. This updates the properties"]
    #[doc = " of the associated client."]
    #[doc = " \\return the number of properties that were updated"]
    pub fn pw_core_update_properties(
        core: *mut pw_core,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the core mempool object"]
    pub fn pw_core_get_mempool(core: *mut pw_core) -> *mut pw_mempool;
}
extern "C" {
    #[doc = " Get the proxy with the given id"]
    pub fn pw_core_find_proxy(core: *mut pw_core, id: u32) -> *mut pw_proxy;
}
extern "C" {
    #[doc = " Export an object into the PipeWire instance associated with core"]
    pub fn pw_core_export(
        core: *mut pw_core,
        type_: *const ::std::os::raw::c_char,
        props: *const spa_dict,
        object: *mut ::std::os::raw::c_void,
        user_data_size: usize,
    ) -> *mut pw_proxy;
}
#[repr(C)]
pub struct spa_system {
    pub iface: spa_interface,
}
#[repr(C)]
pub struct spa_poll_event {
    pub events: u32,
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
pub struct spa_system_methods {
    pub version: u32,
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            buf: *mut ::std::os::raw::c_void,
            count: usize,
        ) -> isize,
    >,
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            buf: *const ::std::os::raw::c_void,
            count: usize,
        ) -> isize,
    >,
    pub ioctl: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            request: ::std::os::raw::c_ulong,
            ...
        ) -> ::std::os::raw::c_int,
    >,
    pub close: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub clock_gettime: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            clockid: ::std::os::raw::c_int,
            value: *mut timespec,
        ) -> ::std::os::raw::c_int,
    >,
    pub clock_getres: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            clockid: ::std::os::raw::c_int,
            res: *mut timespec,
        ) -> ::std::os::raw::c_int,
    >,
    pub pollfd_create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub pollfd_add: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            pfd: ::std::os::raw::c_int,
            fd: ::std::os::raw::c_int,
            events: u32,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub pollfd_mod: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            pfd: ::std::os::raw::c_int,
            fd: ::std::os::raw::c_int,
            events: u32,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub pollfd_del: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            pfd: ::std::os::raw::c_int,
            fd: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub pollfd_wait: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            pfd: ::std::os::raw::c_int,
            ev: *mut spa_poll_event,
            n_ev: ::std::os::raw::c_int,
            timeout: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub timerfd_create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            clockid: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub timerfd_settime: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
            new_value: *const itimerspec,
            old_value: *mut itimerspec,
        ) -> ::std::os::raw::c_int,
    >,
    pub timerfd_gettime: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            curr_value: *mut itimerspec,
        ) -> ::std::os::raw::c_int,
    >,
    pub timerfd_read: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            expirations: *mut u64,
        ) -> ::std::os::raw::c_int,
    >,
    pub eventfd_create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub eventfd_write: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            count: u64,
        ) -> ::std::os::raw::c_int,
    >,
    pub eventfd_read: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            count: *mut u64,
        ) -> ::std::os::raw::c_int,
    >,
    pub signalfd_create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            signal: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub signalfd_read: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            signal: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
#[repr(C)]
pub struct spa_loop {
    pub iface: spa_interface,
}
#[repr(C)]
pub struct spa_loop_control {
    pub iface: spa_interface,
}
#[repr(C)]
pub struct spa_loop_utils {
    pub iface: spa_interface,
}
pub type spa_source_func_t = ::std::option::Option<unsafe extern "C" fn(source: *mut spa_source)>;
#[repr(C)]
pub struct spa_source {
    pub loop_: *mut spa_loop,
    pub func: spa_source_func_t,
    pub data: *mut ::std::os::raw::c_void,
    pub fd: ::std::os::raw::c_int,
    pub mask: u32,
    pub rmask: u32,
}
pub type spa_invoke_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        loop_: *mut spa_loop,
        async_: bool,
        seq: u32,
        data: *const ::std::os::raw::c_void,
        size: usize,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Register sources and work items to an event loop"]
#[repr(C)]
pub struct spa_loop_methods {
    pub version: u32,
    #[doc = " add a source to the loop"]
    pub add_source: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " update the source io mask"]
    pub update_source: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " remove a source from the loop"]
    pub remove_source: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " invoke a function in the context of this loop"]
    pub invoke: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            func: spa_invoke_func_t,
            seq: u32,
            data: *const ::std::os::raw::c_void,
            size: usize,
            block: bool,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = " Control hooks. These hooks can't be removed from their"]
#[doc = "  callbacks and must be removed from a safe place (when the loop"]
#[doc = "  is not running or when it is locked)."]
#[repr(C)]
pub struct spa_loop_control_hooks {
    pub version: u32,
    #[doc = " Executed right before waiting for events. It is typically used to"]
    #[doc = " release locks."]
    pub before: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Executed right after waiting for events. It is typically used to"]
    #[doc = " reacquire locks."]
    pub after: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[doc = " Control an event loop"]
#[repr(C)]
pub struct spa_loop_control_methods {
    pub version: u32,
    pub get_fd: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    #[doc = " Add a hook"]
    #[doc = " \\param ctrl the control to change"]
    #[doc = " \\param hooks the hooks to add"]
    #[doc = ""]
    #[doc = " Adds hooks to the loop controlled by \\a ctrl."]
    pub add_hook: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            hook: *mut spa_hook,
            hooks: *const spa_loop_control_hooks,
            data: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Enter a loop"]
    #[doc = " \\param ctrl the control"]
    #[doc = ""]
    #[doc = " Start an iteration of the loop. This function should be called"]
    #[doc = " before calling iterate and is typically used to capture the thread"]
    #[doc = " that this loop will run in."]
    pub enter: ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void)>,
    #[doc = " Leave a loop"]
    #[doc = " \\param ctrl the control"]
    #[doc = ""]
    #[doc = " Ends the iteration of a loop. This should be called after calling"]
    #[doc = " iterate."]
    pub leave: ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void)>,
    #[doc = " Perform one iteration of the loop."]
    #[doc = " \\param ctrl the control"]
    #[doc = " \\param timeout an optional timeout in milliseconds."]
    #[doc = "\t0 for no timeout, -1 for infinite timeout."]
    #[doc = ""]
    #[doc = " This function will block"]
    #[doc = " up to \\a timeout milliseconds and then dispatch the fds with activity."]
    #[doc = " The number of dispatched fds is returned."]
    pub iterate: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            timeout: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
pub type spa_source_io_func_t = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, fd: ::std::os::raw::c_int, mask: u32),
>;
pub type spa_source_idle_func_t =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>;
pub type spa_source_event_func_t =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, count: u64)>;
pub type spa_source_timer_func_t = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, expirations: u64),
>;
pub type spa_source_signal_func_t = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, signal_number: ::std::os::raw::c_int),
>;
#[doc = " Create sources for an event loop"]
#[repr(C)]
pub struct spa_loop_utils_methods {
    pub version: u32,
    pub add_io: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            mask: u32,
            close: bool,
            func: spa_source_io_func_t,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut spa_source,
    >,
    pub update_io: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
            mask: u32,
        ) -> ::std::os::raw::c_int,
    >,
    pub add_idle: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            enabled: bool,
            func: spa_source_idle_func_t,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut spa_source,
    >,
    pub enable_idle: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
            enabled: bool,
        ) -> ::std::os::raw::c_int,
    >,
    pub add_event: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            func: spa_source_event_func_t,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut spa_source,
    >,
    pub signal_event: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
        ) -> ::std::os::raw::c_int,
    >,
    pub add_timer: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            func: spa_source_timer_func_t,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut spa_source,
    >,
    pub update_timer: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
            value: *mut timespec,
            interval: *mut timespec,
            absolute: bool,
        ) -> ::std::os::raw::c_int,
    >,
    pub add_signal: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            signal_number: ::std::os::raw::c_int,
            func: spa_source_signal_func_t,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut spa_source,
    >,
    #[doc = " destroy a source allocated with this interface. This function"]
    #[doc = " should only be called when the loop is not running or from the"]
    #[doc = " context of the running loop"]
    pub destroy_source: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void, source: *mut spa_source),
    >,
}
#[doc = " \\class pw_loop"]
#[doc = ""]
#[doc = " PipeWire loop object provides an implementation of"]
#[doc = " the spa loop interfaces. It can be used to implement various"]
#[doc = " event loops."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_loop {
    #[doc = "< system utils"]
    pub system: *mut spa_system,
    #[doc = "< wrapped loop"]
    pub loop_: *mut spa_loop,
    #[doc = "< loop control"]
    pub control: *mut spa_loop_control,
    #[doc = "< loop utils"]
    pub utils: *mut spa_loop_utils,
}
extern "C" {
    pub fn pw_loop_new(props: *const spa_dict) -> *mut pw_loop;
}
extern "C" {
    pub fn pw_loop_destroy(loop_: *mut pw_loop);
}
#[doc = " context events emitted by the context object added with \\ref pw_context_add_listener"]
#[repr(C)]
pub struct pw_context_events {
    pub version: u32,
    #[doc = " The context is being destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " The context is being freed"]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " a new client object is added"]
    pub check_access: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, client: *mut pw_impl_client),
    >,
    #[doc = " a new global object was added"]
    pub global_added: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, global: *mut pw_global),
    >,
    #[doc = " a global object was removed"]
    pub global_removed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, global: *mut pw_global),
    >,
}
extern "C" {
    #[doc = " Make a new context object for a given main_loop. Ownership of the properties is taken"]
    pub fn pw_context_new(
        main_loop: *mut pw_loop,
        props: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_context;
}
extern "C" {
    #[doc = " destroy a context object, all resources except the main_loop will be destroyed"]
    pub fn pw_context_destroy(context: *mut pw_context);
}
extern "C" {
    #[doc = " Get the context user data"]
    pub fn pw_context_get_user_data(context: *mut pw_context) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Add a new event listener to a context"]
    pub fn pw_context_add_listener(
        context: *mut pw_context,
        listener: *mut spa_hook,
        events: *const pw_context_events,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Get the context properties"]
    pub fn pw_context_get_properties(context: *mut pw_context) -> *const pw_properties;
}
extern "C" {
    #[doc = " Update the context properties"]
    pub fn pw_context_update_properties(
        context: *mut pw_context,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a config section for this context. Since 0.3.22"]
    pub fn pw_context_get_conf_section(
        context: *mut pw_context,
        section: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the context support objects"]
    pub fn pw_context_get_support(
        context: *mut pw_context,
        n_support: *mut u32,
    ) -> *const spa_support;
}
extern "C" {
    #[doc = " get the context main loop"]
    pub fn pw_context_get_main_loop(context: *mut pw_context) -> *mut pw_loop;
}
extern "C" {
    #[doc = " Iterate the globals of the context. The callback should return"]
    #[doc = " 0 to fetch the next item, any other value stops the iteration and returns"]
    #[doc = " the value. When all callbacks return 0, this function returns 0 when all"]
    #[doc = " globals are iterated."]
    pub fn pw_context_for_each_global(
        context: *mut pw_context,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                global: *mut pw_global,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find a context global by id"]
    pub fn pw_context_find_global(context: *mut pw_context, id: u32) -> *mut pw_global;
}
extern "C" {
    #[doc = " add a spa library for the given factory_name regex"]
    pub fn pw_context_add_spa_lib(
        context: *mut pw_context,
        factory_regex: *const ::std::os::raw::c_char,
        lib: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " find the library name for a spa factory"]
    pub fn pw_context_find_spa_lib(
        context: *mut pw_context,
        factory_name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pw_context_load_spa_handle(
        context: *mut pw_context,
        factory_name: *const ::std::os::raw::c_char,
        info: *const spa_dict,
    ) -> *mut spa_handle;
}
#[doc = " data for registering export functions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_export_type {
    pub link: spa_list,
    pub type_: *const ::std::os::raw::c_char,
    pub func: ::std::option::Option<
        unsafe extern "C" fn(
            core: *mut pw_core,
            type_: *const ::std::os::raw::c_char,
            props: *const spa_dict,
            object: *mut ::std::os::raw::c_void,
            user_data_size: usize,
        ) -> *mut pw_proxy,
    >,
}
extern "C" {
    #[doc = " register a type that can be exported on a context_proxy. This is usually used by"]
    #[doc = " extension modules"]
    pub fn pw_context_register_export_type(
        context: *mut pw_context,
        type_: *mut pw_export_type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " find information about registered export type"]
    pub fn pw_context_find_export_type(
        context: *mut pw_context,
        type_: *const ::std::os::raw::c_char,
    ) -> *const pw_export_type;
}
extern "C" {
    #[doc = " add an object to the context"]
    pub fn pw_context_set_object(
        context: *mut pw_context,
        type_: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get an object from the context"]
    pub fn pw_context_get_object(
        context: *mut pw_context,
        type_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
pub struct spa_type_info {
    pub type_: u32,
    pub parent: u32,
    pub name: *const ::std::os::raw::c_char,
    pub values: *const spa_type_info,
}
#[repr(C)]
pub struct spa_pod {
    pub size: u32,
    pub type_: u32,
}
#[repr(C)]
pub struct spa_pod_bool {
    pub pod: spa_pod,
    pub value: i32,
    pub _padding: i32,
}
#[repr(C)]
pub struct spa_pod_id {
    pub pod: spa_pod,
    pub value: u32,
    pub _padding: i32,
}
#[repr(C)]
pub struct spa_pod_int {
    pub pod: spa_pod,
    pub value: i32,
    pub _padding: i32,
}
#[repr(C)]
pub struct spa_pod_long {
    pub pod: spa_pod,
    pub value: i64,
}
#[repr(C)]
pub struct spa_pod_float {
    pub pod: spa_pod,
    pub value: f32,
    pub _padding: i32,
}
#[repr(C)]
pub struct spa_pod_double {
    pub pod: spa_pod,
    pub value: f64,
}
#[repr(C)]
pub struct spa_pod_string {
    pub pod: spa_pod,
}
#[repr(C)]
pub struct spa_pod_bytes {
    pub pod: spa_pod,
}
#[repr(C)]
pub struct spa_pod_rectangle {
    pub pod: spa_pod,
    pub value: spa_rectangle,
}
#[repr(C)]
pub struct spa_pod_fraction {
    pub pod: spa_pod,
    pub value: spa_fraction,
}
#[repr(C)]
pub struct spa_pod_bitmap {
    pub pod: spa_pod,
}
#[repr(C)]
pub struct spa_pod_array_body {
    pub child: spa_pod,
}
#[repr(C)]
pub struct spa_pod_array {
    pub pod: spa_pod,
    pub body: spa_pod_array_body,
}
#[doc = "< no choice, first value is current"]
pub const SPA_CHOICE_None: spa_choice_type = 0;
#[doc = "< range: default, min, max"]
pub const SPA_CHOICE_Range: spa_choice_type = 1;
#[doc = "< range with step: default, min, max, step"]
pub const SPA_CHOICE_Step: spa_choice_type = 2;
#[doc = "< list: default, alternative,..."]
pub const SPA_CHOICE_Enum: spa_choice_type = 3;
#[doc = "< flags: default, possible flags,..."]
pub const SPA_CHOICE_Flags: spa_choice_type = 4;
pub type spa_choice_type = ::std::os::raw::c_uint;
#[repr(C)]
pub struct spa_pod_choice_body {
    #[doc = "< type of choice, one of enum spa_choice_type"]
    pub type_: u32,
    #[doc = "< extra flags"]
    pub flags: u32,
    pub child: spa_pod,
}
#[repr(C)]
pub struct spa_pod_choice {
    pub pod: spa_pod,
    pub body: spa_pod_choice_body,
}
#[repr(C)]
pub struct spa_pod_struct {
    pub pod: spa_pod,
}
#[repr(C)]
pub struct spa_pod_object_body {
    #[doc = "< one of enum spa_type"]
    pub type_: u32,
    #[doc = "< id of the object, depends on the object type"]
    pub id: u32,
}
#[repr(C)]
pub struct spa_pod_object {
    pub pod: spa_pod,
    pub body: spa_pod_object_body,
}
#[repr(C)]
pub struct spa_pod_pointer_body {
    #[doc = "< pointer id, one of enum spa_type"]
    pub type_: u32,
    pub _padding: u32,
    pub value: *const ::std::os::raw::c_void,
}
#[repr(C)]
pub struct spa_pod_pointer {
    pub pod: spa_pod,
    pub body: spa_pod_pointer_body,
}
#[repr(C)]
pub struct spa_pod_fd {
    pub pod: spa_pod,
    pub value: i64,
}
#[repr(C)]
pub struct spa_pod_prop {
    #[doc = "< key of property, list of valid keys depends on the"]
    #[doc = "  object type"]
    pub key: u32,
    #[doc = "< flags for property"]
    pub flags: u32,
    pub value: spa_pod,
}
#[repr(C)]
pub struct spa_pod_control {
    #[doc = "< media offset"]
    pub offset: u32,
    #[doc = "< type of control, enum spa_control_type"]
    pub type_: u32,
    #[doc = "< control value, depends on type"]
    pub value: spa_pod,
}
#[repr(C)]
pub struct spa_pod_sequence_body {
    pub unit: u32,
    pub pad: u32,
}
#[doc = " a sequence of timed controls"]
#[repr(C)]
pub struct spa_pod_sequence {
    pub pod: spa_pod,
    pub body: spa_pod_sequence_body,
}
#[doc = " a function to destroy an item \\memberof pw_utils"]
pub type pw_destroy_t =
    ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn pw_split_walk(
        str_: *const ::std::os::raw::c_char,
        delimiter: *const ::std::os::raw::c_char,
        len: *mut usize,
        state: *mut *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pw_split_strv(
        str_: *const ::std::os::raw::c_char,
        delimiter: *const ::std::os::raw::c_char,
        max_tokens: ::std::os::raw::c_int,
        n_tokens: *mut ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pw_free_strv(str_: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn pw_strip(
        str_: *mut ::std::os::raw::c_char,
        whitespace: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_protocol_client {
    #[doc = "< link in protocol client_list"]
    pub link: spa_list,
    #[doc = "< the owner protocol"]
    pub protocol: *mut pw_protocol,
    pub core: *mut pw_core,
    pub connect: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut pw_protocol_client,
            props: *const spa_dict,
            done_callback: ::std::option::Option<
                unsafe extern "C" fn(
                    data: *mut ::std::os::raw::c_void,
                    result: ::std::os::raw::c_int,
                ),
            >,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub connect_fd: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut pw_protocol_client,
            fd: ::std::os::raw::c_int,
            close: bool,
        ) -> ::std::os::raw::c_int,
    >,
    pub steal_fd: ::std::option::Option<
        unsafe extern "C" fn(client: *mut pw_protocol_client) -> ::std::os::raw::c_int,
    >,
    pub disconnect: ::std::option::Option<unsafe extern "C" fn(client: *mut pw_protocol_client)>,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(client: *mut pw_protocol_client)>,
    pub set_paused: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut pw_protocol_client,
            paused: bool,
        ) -> ::std::os::raw::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_protocol_server {
    #[doc = "< link in protocol server_list"]
    pub link: spa_list,
    #[doc = "< the owner protocol"]
    pub protocol: *mut pw_protocol,
    pub core: *mut pw_impl_core,
    #[doc = "< list of clients of this protocol"]
    pub client_list: spa_list,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(listen: *mut pw_protocol_server)>,
}
#[repr(C)]
pub struct pw_protocol_marshal {
    #[doc = "< interface type"]
    pub type_: *const ::std::os::raw::c_char,
    #[doc = "< version"]
    pub version: u32,
    #[doc = "< version"]
    pub flags: u32,
    #[doc = "< number of client methods"]
    pub n_client_methods: u32,
    #[doc = "< number of server methods"]
    pub n_server_methods: u32,
    pub client_marshal: *const ::std::os::raw::c_void,
    pub server_demarshal: *const ::std::os::raw::c_void,
    pub server_marshal: *const ::std::os::raw::c_void,
    pub client_demarshal: *const ::std::os::raw::c_void,
}
#[repr(C)]
pub struct pw_protocol_implementaton {
    pub version: u32,
    pub new_client: ::std::option::Option<
        unsafe extern "C" fn(
            protocol: *mut pw_protocol,
            core: *mut pw_core,
            props: *const spa_dict,
        ) -> *mut pw_protocol_client,
    >,
    pub add_server: ::std::option::Option<
        unsafe extern "C" fn(
            protocol: *mut pw_protocol,
            core: *mut pw_impl_core,
            props: *const spa_dict,
        ) -> *mut pw_protocol_server,
    >,
}
#[repr(C)]
pub struct pw_protocol_events {
    pub version: u32,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
extern "C" {
    pub fn pw_protocol_new(
        context: *mut pw_context,
        name: *const ::std::os::raw::c_char,
        user_data_size: usize,
    ) -> *mut pw_protocol;
}
extern "C" {
    pub fn pw_protocol_destroy(protocol: *mut pw_protocol);
}
extern "C" {
    pub fn pw_protocol_get_context(protocol: *mut pw_protocol) -> *mut pw_context;
}
extern "C" {
    pub fn pw_protocol_get_user_data(protocol: *mut pw_protocol) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pw_protocol_get_implementation(
        protocol: *mut pw_protocol,
    ) -> *const pw_protocol_implementaton;
}
extern "C" {
    pub fn pw_protocol_get_extension(protocol: *mut pw_protocol) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn pw_protocol_add_listener(
        protocol: *mut pw_protocol,
        listener: *mut spa_hook,
        events: *const pw_protocol_events,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " \\class pw_protocol"]
    #[doc = ""]
    #[doc = " \\brief Manages protocols and their implementation"]
    pub fn pw_protocol_add_marshal(
        protocol: *mut pw_protocol,
        marshal: *const pw_protocol_marshal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pw_protocol_get_marshal(
        protocol: *mut pw_protocol,
        type_: *const ::std::os::raw::c_char,
        version: u32,
        flags: u32,
    ) -> *const pw_protocol_marshal;
}
extern "C" {
    pub fn pw_context_find_protocol(
        context: *mut pw_context,
        name: *const ::std::os::raw::c_char,
    ) -> *mut pw_protocol;
}
#[doc = " Proxy events, use \\ref pw_proxy_add_listener"]
#[repr(C)]
pub struct pw_proxy_events {
    pub version: u32,
    #[doc = " The proxy is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " a proxy is bound to a global id"]
    pub bound: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, global_id: u32),
    >,
    #[doc = " a proxy is removed from the server. Use pw_proxy_destroy to"]
    #[doc = " free the proxy."]
    pub removed: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " a reply to a sync method completed"]
    pub done: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, seq: ::std::os::raw::c_int),
    >,
    #[doc = " an error occurred on the proxy"]
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            res: ::std::os::raw::c_int,
            message: *const ::std::os::raw::c_char,
        ),
    >,
}
extern "C" {
    #[doc = " Make a new proxy object. The id can be used to bind to a remote object and"]
    #[doc = " can be retrieved with \\ref pw_proxy_get_id ."]
    pub fn pw_proxy_new(
        factory: *mut pw_proxy,
        type_: *const ::std::os::raw::c_char,
        version: u32,
        user_data_size: usize,
    ) -> *mut pw_proxy;
}
extern "C" {
    #[doc = " Add an event listener to proxy"]
    pub fn pw_proxy_add_listener(
        proxy: *mut pw_proxy,
        listener: *mut spa_hook,
        events: *const pw_proxy_events,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Add a listener for the events received from the remote object. The"]
    #[doc = " events depend on the type of the remote object type."]
    pub fn pw_proxy_add_object_listener(
        proxy: *mut pw_proxy,
        listener: *mut spa_hook,
        funcs: *const ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " destroy a proxy"]
    pub fn pw_proxy_destroy(proxy: *mut pw_proxy);
}
extern "C" {
    #[doc = " Get the user_data. The size was given in \\ref pw_proxy_new"]
    pub fn pw_proxy_get_user_data(proxy: *mut pw_proxy) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get the local id of the proxy"]
    pub fn pw_proxy_get_id(proxy: *mut pw_proxy) -> u32;
}
extern "C" {
    #[doc = " Get the type and version of the proxy"]
    pub fn pw_proxy_get_type(
        proxy: *mut pw_proxy,
        version: *mut u32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the protocol used for the proxy"]
    pub fn pw_proxy_get_protocol(proxy: *mut pw_proxy) -> *mut pw_protocol;
}
extern "C" {
    #[doc = " Generate an sync method for a proxy. This will generate a done event"]
    #[doc = " with the same seq number of the reply."]
    pub fn pw_proxy_sync(proxy: *mut pw_proxy, seq: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the global id this proxy is bound to. This is usually used internally"]
    #[doc = " and will also emit the bound event"]
    pub fn pw_proxy_set_bound_id(proxy: *mut pw_proxy, global_id: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the global id bound to this proxy of SPA_ID_INVALID when not bound"]
    #[doc = " to a global"]
    pub fn pw_proxy_get_bound_id(proxy: *mut pw_proxy) -> u32;
}
extern "C" {
    #[doc = " Generate an error for a proxy"]
    pub fn pw_proxy_error(
        proxy: *mut pw_proxy,
        res: ::std::os::raw::c_int,
        error: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pw_proxy_errorf(
        proxy: *mut pw_proxy,
        res: ::std::os::raw::c_int,
        error: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the listener of proxy"]
    pub fn pw_proxy_get_object_listeners(proxy: *mut pw_proxy) -> *mut spa_hook_list;
}
extern "C" {
    #[doc = " Get the marshal functions for the proxy"]
    pub fn pw_proxy_get_marshal(proxy: *mut pw_proxy) -> *const pw_protocol_marshal;
}
extern "C" {
    #[doc = " Install a marshal function on a proxy"]
    pub fn pw_proxy_install_marshal(
        proxy: *mut pw_proxy,
        implementor: bool,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
pub struct pw_permission {
    #[doc = "< id of object, PW_ID_ANY for default permission"]
    pub id: u32,
    #[doc = "< bitmask of above permissions"]
    pub permissions: u32,
}
#[doc = " The client information. Extra information can be added in later versions \\memberof pw_introspect"]
#[repr(C)]
pub struct pw_client_info {
    #[doc = "< id of the global"]
    pub id: u32,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< extra properties"]
    pub props: *mut spa_dict,
}
extern "C" {
    #[doc = " Update and existing \\ref pw_client_info with \\a update \\memberof pw_introspect"]
    pub fn pw_client_info_update(
        info: *mut pw_client_info,
        update: *const pw_client_info,
    ) -> *mut pw_client_info;
}
extern "C" {
    #[doc = " Free a \\ref pw_client_info \\memberof pw_introspect"]
    pub fn pw_client_info_free(info: *mut pw_client_info);
}
#[doc = " Client events"]
#[repr(C)]
pub struct pw_client_events {
    pub version: u32,
    #[doc = " Notify client info"]
    #[doc = ""]
    #[doc = " \\param info info about the client"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void, info: *const pw_client_info),
    >,
    #[doc = " Notify a client permission"]
    #[doc = ""]
    #[doc = " Event emitted as a result of the get_permissions method."]
    #[doc = ""]
    #[doc = " \\param default_permissions the default permissions"]
    #[doc = " \\param index the index of the first permission entry"]
    #[doc = " \\param n_permissions the number of permissions"]
    #[doc = " \\param permissions the permissions"]
    pub permissions: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            index: u32,
            n_permissions: u32,
            permissions: *const pw_permission,
        ),
    >,
}
#[doc = " Client methods"]
#[repr(C)]
pub struct pw_client_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_client_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Send an error to a client"]
    #[doc = ""]
    #[doc = " \\param id the global id to report the error on"]
    #[doc = " \\param res an errno style error code"]
    #[doc = " \\param message an error string"]
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            res: ::std::os::raw::c_int,
            message: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Update client properties"]
    #[doc = ""]
    #[doc = " \\param props new properties"]
    pub update_properties: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            props: *const spa_dict,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Get client permissions"]
    #[doc = ""]
    #[doc = " A permissions event will be emitted with the permissions."]
    #[doc = ""]
    #[doc = " \\param index the first index to query, 0 for first"]
    #[doc = " \\param num the maximum number of items to get"]
    pub get_permissions: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            index: u32,
            num: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Manage the permissions of the global objects for this"]
    #[doc = " client"]
    #[doc = ""]
    #[doc = " Update the permissions of the global objects using the"]
    #[doc = " provided array with permissions"]
    #[doc = ""]
    #[doc = " Globals can use the default permissions or can have specific"]
    #[doc = " permissions assigned to them."]
    #[doc = ""]
    #[doc = " \\param n_permissions number of permissions"]
    #[doc = " \\param permissions array of permissions"]
    pub update_permissions: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            n_permissions: u32,
            permissions: *const pw_permission,
        ) -> ::std::os::raw::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_device {
    _unused: [u8; 0],
}
#[doc = " The device information. Extra information can be added in later versions \\memberof pw_introspect"]
#[repr(C)]
pub struct pw_device_info {
    #[doc = "< id of the global"]
    pub id: u32,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< extra properties"]
    pub props: *mut spa_dict,
    #[doc = "< parameters"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
extern "C" {
    #[doc = " Update and existing \\ref pw_device_info with \\a update \\memberof pw_introspect"]
    pub fn pw_device_info_update(
        info: *mut pw_device_info,
        update: *const pw_device_info,
    ) -> *mut pw_device_info;
}
extern "C" {
    #[doc = " Free a \\ref pw_device_info \\memberof pw_introspect"]
    pub fn pw_device_info_free(info: *mut pw_device_info);
}
#[doc = " Device events"]
#[repr(C)]
pub struct pw_device_events {
    pub version: u32,
    #[doc = " Notify device info"]
    #[doc = ""]
    #[doc = " \\param info info about the device"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void, info: *const pw_device_info),
    >,
    #[doc = " Notify a device param"]
    #[doc = ""]
    #[doc = " Event emitted as a result of the enum_params method."]
    #[doc = ""]
    #[doc = " \\param seq the sequence number of the request"]
    #[doc = " \\param id the param id"]
    #[doc = " \\param index the param index"]
    #[doc = " \\param next the param index of the next param"]
    #[doc = " \\param param the parameter"]
    pub param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            index: u32,
            next: u32,
            param: *const spa_pod,
        ),
    >,
}
#[doc = " Device methods"]
#[repr(C)]
pub struct pw_device_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_device_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Subscribe to parameter changes"]
    #[doc = ""]
    #[doc = " Automatically emit param events for the given ids when"]
    #[doc = " they are changed."]
    #[doc = ""]
    #[doc = " \\param ids an array of param ids"]
    #[doc = " \\param n_ids the number of ids in \\a ids"]
    pub subscribe_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            ids: *mut u32,
            n_ids: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate device parameters"]
    #[doc = ""]
    #[doc = " Start enumeration of device parameters. For each param, a"]
    #[doc = " param event will be emitted."]
    #[doc = ""]
    #[doc = " \\param seq a sequence number to place in the reply"]
    #[doc = " \\param id the parameter id to enum or PW_ID_ANY for all"]
    #[doc = " \\param start the start index or 0 for the first param"]
    #[doc = " \\param num the maximum number of params to retrieve"]
    #[doc = " \\param filter a param filter or NULL"]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            start: u32,
            num: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set a parameter on the device"]
    #[doc = ""]
    #[doc = " \\param id the parameter id to set"]
    #[doc = " \\param flags extra parameter flags"]
    #[doc = " \\param param the parameter to set"]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
}
pub const SPA_META_Invalid: spa_meta_type = 0;
#[doc = "< struct spa_meta_header"]
pub const SPA_META_Header: spa_meta_type = 1;
#[doc = "< struct spa_meta_region with cropping data"]
pub const SPA_META_VideoCrop: spa_meta_type = 2;
#[doc = "< array of struct spa_meta_region with damage"]
pub const SPA_META_VideoDamage: spa_meta_type = 3;
#[doc = "< struct spa_meta_bitmap"]
pub const SPA_META_Bitmap: spa_meta_type = 4;
#[doc = "< struct spa_meta_cursor"]
pub const SPA_META_Cursor: spa_meta_type = 5;
#[doc = "< metadata contains a spa_meta_control"]
#[doc = "  associated with the data"]
pub const SPA_META_Control: spa_meta_type = 6;
#[doc = "< don't write to buffer when count > 0"]
pub const SPA_META_Busy: spa_meta_type = 7;
#[doc = "< not part of ABI/API"]
pub const SPA_META_LAST: spa_meta_type = 8;
#[doc = " \\page page_meta Metadata"]
#[doc = ""]
#[doc = " Metadata contains extra information on a buffer."]
pub type spa_meta_type = ::std::os::raw::c_uint;
#[doc = " A metadata element."]
#[doc = ""]
#[doc = " This structure is available on the buffer structure and contains"]
#[doc = " the type of the metadata and a pointer/size to the actual metadata"]
#[doc = " itself."]
#[repr(C)]
pub struct spa_meta {
    #[doc = "< metadata type, one of enum spa_meta_type"]
    pub type_: u32,
    #[doc = "< size of metadata"]
    pub size: u32,
    #[doc = "< pointer to metadata"]
    pub data: *mut ::std::os::raw::c_void,
}
#[doc = " Describes essential buffer header metadata such as flags and"]
#[doc = " timestamps."]
#[repr(C)]
pub struct spa_meta_header {
    #[doc = "< flags"]
    pub flags: u32,
    #[doc = "< offset in current cycle"]
    pub offset: u32,
    #[doc = "< presentation timestamp"]
    pub pts: i64,
    #[doc = "< decoding timestamp as a difference with pts"]
    pub dts_offset: i64,
    #[doc = "< sequence number, increments with a"]
    #[doc = "  media specific frequency"]
    pub seq: u64,
}
#[doc = " metadata structure for Region or an array of these for RegionArray"]
#[repr(C)]
pub struct spa_meta_region {
    pub region: spa_region,
}
#[doc = " Bitmap information"]
#[doc = ""]
#[doc = " This metadata contains a bitmap image in the given format and size."]
#[doc = " It is typically used for cursor images or other small images that are"]
#[doc = " better transferred inline."]
#[repr(C)]
pub struct spa_meta_bitmap {
    #[doc = "< bitmap video format, one of enum spa_video_format. 0 is"]
    #[doc = "  and invalid format and should be handled as if there is"]
    #[doc = "  no new bitmap information."]
    pub format: u32,
    #[doc = "< width and height of bitmap"]
    pub size: spa_rectangle,
    #[doc = "< stride of bitmap data"]
    pub stride: i32,
    #[doc = "< offset of bitmap data in this structure. An offset of"]
    #[doc = "  0 means no image data (invisible), an offset >="]
    #[doc = "  sizeof(struct spa_meta_bitmap) contains valid bitmap"]
    #[doc = "  info."]
    pub offset: u32,
}
#[doc = " Cursor information"]
#[doc = ""]
#[doc = " Metadata to describe the position and appearance of a pointing device."]
#[repr(C)]
pub struct spa_meta_cursor {
    #[doc = "< cursor id. an id of 0 is an invalid id and means that"]
    #[doc = "  there is no new cursor data"]
    pub id: u32,
    #[doc = "< extra flags"]
    pub flags: u32,
    #[doc = "< position on screen"]
    pub position: spa_point,
    #[doc = "< offsets for hotspot in bitmap, this field has no meaning"]
    #[doc = "  when there is no valid bitmap (see below)"]
    pub hotspot: spa_point,
    #[doc = "< offset of bitmap meta in this structure. When the offset"]
    #[doc = "  is 0, there is no new bitmap information. When the offset is"]
    #[doc = "  >= sizeof(struct spa_meta_cursor) there is a"]
    #[doc = "  struct spa_meta_bitmap at the offset."]
    pub bitmap_offset: u32,
}
#[doc = " a timed set of events associated with the buffer"]
#[repr(C)]
pub struct spa_meta_control {
    pub sequence: spa_pod_sequence,
}
#[doc = " a busy counter for the buffer"]
#[repr(C)]
pub struct spa_meta_busy {
    pub flags: u32,
    #[doc = "< number of users busy with the buffer"]
    pub count: u32,
}
pub const SPA_DATA_Invalid: spa_data_type = 0;
#[doc = "< pointer to memory, the data field in"]
#[doc = "  struct spa_data is set."]
pub const SPA_DATA_MemPtr: spa_data_type = 1;
#[doc = "< generic fd, mmap to get to memory"]
pub const SPA_DATA_MemFd: spa_data_type = 2;
#[doc = "< fd to dmabuf memory"]
pub const SPA_DATA_DmaBuf: spa_data_type = 3;
#[doc = "< memory is identified with an id"]
pub const SPA_DATA_MemId: spa_data_type = 4;
#[doc = "< not part of ABI"]
pub const SPA_DATA_LAST: spa_data_type = 5;
#[doc = " \\page page_buffer Buffers"]
#[doc = ""]
#[doc = " Buffers describe the data and metadata that is exchanged between"]
#[doc = " ports of a node."]
pub type spa_data_type = ::std::os::raw::c_uint;
#[doc = " Chunk of memory, can change for each buffer"]
#[repr(C)]
pub struct spa_chunk {
    #[doc = "< offset of valid data. Should be taken"]
    #[doc = "  modulo the data maxsize to get the offset"]
    #[doc = "  in the data memory."]
    pub offset: u32,
    #[doc = "< size of valid data. Should be clamped to"]
    #[doc = "  maxsize."]
    pub size: u32,
    #[doc = "< stride of valid data"]
    pub stride: i32,
    #[doc = "< chunk flags"]
    pub flags: i32,
}
#[doc = " Data for a buffer this stays constant for a buffer"]
#[repr(C)]
pub struct spa_data {
    #[doc = "< memory type, one of enum spa_data_type, when"]
    #[doc = "  allocating memory, the type contains a bitmask"]
    #[doc = "  of allowed types. SPA_ID_INVALID is a special"]
    #[doc = "  value for the allocator to indicate that the"]
    #[doc = "  other side did not explicitly specify any"]
    #[doc = "  supported data types. It should probably use"]
    #[doc = "  a memory type that does not require special"]
    #[doc = "  handling in addition to simple mmap/munmap."]
    pub type_: u32,
    #[doc = "< data flags"]
    pub flags: u32,
    #[doc = "< optional fd for data"]
    pub fd: i64,
    #[doc = "< offset to map fd at"]
    pub mapoffset: u32,
    #[doc = "< max size of data"]
    pub maxsize: u32,
    #[doc = "< optional data pointer"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< valid chunk of memory"]
    pub chunk: *mut spa_chunk,
}
#[doc = " A Buffer"]
#[repr(C)]
pub struct spa_buffer {
    #[doc = "< number of metadata"]
    pub n_metas: u32,
    #[doc = "< number of data members"]
    pub n_datas: u32,
    #[doc = "< array of metadata"]
    pub metas: *mut spa_meta,
    #[doc = "< array of data members"]
    pub datas: *mut spa_data,
}
#[repr(C)]
pub struct spa_event_body {
    pub body: spa_pod_object_body,
}
#[repr(C)]
pub struct spa_event {
    pub pod: spa_pod,
    pub body: spa_event_body,
}
pub const SPA_NODE_EVENT_Error: spa_node_event = 0;
pub const SPA_NODE_EVENT_Buffering: spa_node_event = 1;
pub const SPA_NODE_EVENT_RequestRefresh: spa_node_event = 2;
pub type spa_node_event = ::std::os::raw::c_uint;
#[repr(C)]
pub struct spa_command_body {
    pub body: spa_pod_object_body,
}
#[repr(C)]
pub struct spa_command {
    pub pod: spa_pod,
    pub body: spa_command_body,
}
#[doc = "< suspend a node, this removes all configured"]
#[doc = " formats and closes any devices"]
pub const SPA_NODE_COMMAND_Suspend: spa_node_command = 0;
#[doc = "< pause a node. this makes it stop emitting"]
#[doc = "  scheduling events"]
pub const SPA_NODE_COMMAND_Pause: spa_node_command = 1;
#[doc = "< start a node, this makes it start emitting"]
#[doc = "  scheduling events"]
pub const SPA_NODE_COMMAND_Start: spa_node_command = 2;
pub const SPA_NODE_COMMAND_Enable: spa_node_command = 3;
pub const SPA_NODE_COMMAND_Disable: spa_node_command = 4;
pub const SPA_NODE_COMMAND_Flush: spa_node_command = 5;
pub const SPA_NODE_COMMAND_Drain: spa_node_command = 6;
pub const SPA_NODE_COMMAND_Marker: spa_node_command = 7;
#[doc = "< begin a set of parameter enumerations or"]
#[doc = "  configuration that require the device to"]
#[doc = "  remain opened, like query formats and then"]
#[doc = "  set a format"]
pub const SPA_NODE_COMMAND_ParamBegin: spa_node_command = 8;
#[doc = "< end a transaction"]
pub const SPA_NODE_COMMAND_ParamEnd: spa_node_command = 9;
pub type spa_node_command = ::std::os::raw::c_uint;
#[repr(C)]
pub struct spa_node {
    pub iface: spa_interface,
}
#[doc = " Node information structure"]
#[doc = ""]
#[doc = " Contains the basic node information."]
#[repr(C)]
pub struct spa_node_info {
    pub max_input_ports: u32,
    pub max_output_ports: u32,
    pub change_mask: u64,
    pub flags: u64,
    #[doc = "< extra node properties"]
    pub props: *mut spa_dict,
    #[doc = "< parameter information"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
#[doc = " Port information structure"]
#[doc = ""]
#[doc = " Contains the basic port information."]
#[repr(C)]
pub struct spa_port_info {
    pub change_mask: u64,
    #[doc = "< port flags"]
    pub flags: u64,
    #[doc = "< rate of sequence numbers on port"]
    pub rate: spa_fraction,
    #[doc = "< extra port properties"]
    pub props: *const spa_dict,
    #[doc = "< parameter information"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
#[doc = " an error result"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_result_node_error {
    pub message: *const ::std::os::raw::c_char,
}
#[doc = " the result of enum_params or port_enum_params."]
#[repr(C)]
pub struct spa_result_node_params {
    #[doc = "< id of parameter"]
    pub id: u32,
    #[doc = "< index of parameter"]
    pub index: u32,
    #[doc = "< next index of iteration"]
    pub next: u32,
    #[doc = "< the result param"]
    pub param: *mut spa_pod,
}
#[doc = " events from the spa_node."]
#[doc = ""]
#[doc = " All event are called from the main thread and multiple"]
#[doc = " listeners can be registered for the events with"]
#[doc = " spa_node_add_listener()."]
#[repr(C)]
pub struct spa_node_events {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = " Emitted when info changes"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const spa_node_info),
    >,
    #[doc = " Emitted when port info changes, NULL when port is removed"]
    pub port_info: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port: u32,
            info: *const spa_port_info,
        ),
    >,
    #[doc = " notify a result."]
    #[doc = ""]
    #[doc = " Some methods will trigger a result event with an optional"]
    #[doc = " result of the given type. Look at the documentation of the"]
    #[doc = " method to know when to expect a result event."]
    #[doc = ""]
    #[doc = " The result event can be called synchronously, as an event"]
    #[doc = " called from inside the method itself, in which case the seq"]
    #[doc = " number passed to the method will be passed unchanged."]
    #[doc = ""]
    #[doc = " The result event will be called asynchronously when the"]
    #[doc = " method returned an async return value. In this case, the seq"]
    #[doc = " number in the result will match the async return value of"]
    #[doc = " the method call. Users should match the seq number from"]
    #[doc = " request to the reply."]
    pub result: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            res: ::std::os::raw::c_int,
            type_: u32,
            result: *const ::std::os::raw::c_void,
        ),
    >,
    #[doc = " \\param node a spa_node"]
    #[doc = " \\param event the event that was emitted"]
    #[doc = ""]
    #[doc = " This will be called when an out-of-bound event is notified"]
    #[doc = " on \\a node."]
    pub event: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, event: *const spa_event),
    >,
}
#[doc = " Node callbacks"]
#[doc = ""]
#[doc = " Callbacks are called from the real-time data thread. Only"]
#[doc = " one callback structure can be set on an spa_node."]
#[repr(C)]
pub struct spa_node_callbacks {
    pub version: u32,
    #[doc = " \\param node a spa_node"]
    #[doc = ""]
    #[doc = " The node is ready for processing."]
    #[doc = ""]
    #[doc = " When this function is NULL, synchronous operation is requested"]
    #[doc = " on the ports."]
    pub ready: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            state: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " \\param node a spa_node"]
    #[doc = " \\param port_id an input port_id"]
    #[doc = " \\param buffer_id the buffer id to be reused"]
    #[doc = ""]
    #[doc = " The node has a buffer that can be reused."]
    #[doc = ""]
    #[doc = " When this function is NULL, the buffers to reuse will be set in"]
    #[doc = " the io area of the input ports."]
    pub reuse_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            port_id: u32,
            buffer_id: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " \\param data user data"]
    #[doc = " \\param trigger the timestamp in microseconds when the xrun happened"]
    #[doc = " \\param delay the amount of microseconds of xrun."]
    #[doc = " \\param info an object with extra info (NULL for now)"]
    #[doc = ""]
    #[doc = " The node has encountered an over or underrun"]
    #[doc = ""]
    #[doc = " The info contains an object with more information"]
    pub xrun: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            trigger: u64,
            delay: u64,
            info: *mut spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = " Node methods"]
#[repr(C)]
pub struct spa_node_methods {
    pub version: u32,
    #[doc = " Adds an event listener on \\a node."]
    #[doc = ""]
    #[doc = " Setting the events will trigger the info event and a"]
    #[doc = " port_info event for each managed port on the new"]
    #[doc = " listener."]
    #[doc = ""]
    #[doc = " \\param node a #spa_node"]
    #[doc = " \\param listener a listener"]
    #[doc = " \\param events a #struct spa_node_events"]
    #[doc = " \\param data data passed as first argument in functions of \\a events"]
    #[doc = " \\return 0 on success"]
    #[doc = "\t   < 0 errno on error"]
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const spa_node_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set callbacks to on \\a node."]
    #[doc = " if \\a callbacks is NULL, the current callbacks are removed."]
    #[doc = ""]
    #[doc = " This function must be called from the main thread."]
    #[doc = ""]
    #[doc = " All callbacks are called from the data thread."]
    #[doc = ""]
    #[doc = " \\param node a spa_node"]
    #[doc = " \\param callbacks callbacks to set"]
    #[doc = " \\return 0 on success"]
    #[doc = "         -EINVAL when node is NULL"]
    pub set_callbacks: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            callbacks: *const spa_node_callbacks,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Perform a sync operation."]
    #[doc = ""]
    #[doc = " This method will emit the result event with the given sequence"]
    #[doc = " number synchronously or with the returned async return value"]
    #[doc = " asynchronously."]
    #[doc = ""]
    #[doc = " Because all methods are serialized in the node, this can be used"]
    #[doc = " to wait for completion of all previous method calls."]
    #[doc = ""]
    #[doc = " \\param seq a sequence number"]
    #[doc = " \\return 0 on success"]
    #[doc = "         -EINVAL when node is NULL"]
    #[doc = "         an async result"]
    pub sync: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate the parameters of a node."]
    #[doc = ""]
    #[doc = " Parameters are identified with an \\a id. Some parameters can have"]
    #[doc = " multiple values, see the documentation of the parameter id."]
    #[doc = ""]
    #[doc = " Parameters can be filtered by passing a non-NULL \\a filter."]
    #[doc = ""]
    #[doc = " The function will emit the result event up to \\a max times with"]
    #[doc = " the result value. The seq in the result will either be the \\a seq"]
    #[doc = " number when executed synchronously or the async return value of"]
    #[doc = " this function when executed asynchronously."]
    #[doc = ""]
    #[doc = " This function must be called from the main thread."]
    #[doc = ""]
    #[doc = " \\param node a \\ref spa_node"]
    #[doc = " \\param seq a sequence number to pass to the result event when"]
    #[doc = "\tthis method is executed synchronously."]
    #[doc = " \\param id the param id to enumerate"]
    #[doc = " \\param start the index of enumeration, pass 0 for the first item"]
    #[doc = " \\param max the maximum number of parameters to enumerate"]
    #[doc = " \\param filter and optional filter to use"]
    #[doc = ""]
    #[doc = " \\return 0 when no more items can be iterated."]
    #[doc = "         -EINVAL when invalid arguments are given"]
    #[doc = "         -ENOENT the parameter \\a id is unknown"]
    #[doc = "         -ENOTSUP when there are no parameters"]
    #[doc = "                 implemented on \\a node"]
    #[doc = "         an async return value when the result event will be"]
    #[doc = "             emitted later."]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            start: u32,
            max: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set the configurable parameter in \\a node."]
    #[doc = ""]
    #[doc = " Usually, \\a param will be obtained from enum_params and then"]
    #[doc = " modified but it is also possible to set another spa_pod"]
    #[doc = " as long as its keys and types match a supported object."]
    #[doc = ""]
    #[doc = " Objects with property keys that are not known are ignored."]
    #[doc = ""]
    #[doc = " This function must be called from the main thread."]
    #[doc = ""]
    #[doc = " \\param node a \\ref spa_node"]
    #[doc = " \\param id the parameter id to configure"]
    #[doc = " \\param flags additional flags"]
    #[doc = " \\param param the parameter to configure"]
    #[doc = ""]
    #[doc = " \\return 0 on success"]
    #[doc = "         -EINVAL when node is NULL"]
    #[doc = "         -ENOTSUP when there are no parameters implemented on \\a node"]
    #[doc = "         -ENOENT the parameter is unknown"]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Configure the given memory area with \\a id on \\a node. This"]
    #[doc = " structure is allocated by the host and is used to exchange"]
    #[doc = " data and parameters with the node."]
    #[doc = ""]
    #[doc = " Setting an \\a io of NULL will disable the node io."]
    #[doc = ""]
    #[doc = " This function must be called from the main thread."]
    #[doc = ""]
    #[doc = " \\param id the id of the io area, the available ids can be"]
    #[doc = "        enumerated with the node parameters."]
    #[doc = " \\param data a io area memory"]
    #[doc = " \\param size the size of \\a data"]
    #[doc = " \\return 0 on success"]
    #[doc = "         -EINVAL when invalid input is given"]
    #[doc = "         -ENOENT when \\a id is unknown"]
    #[doc = "         -ENOSPC when \\a size is too small"]
    pub set_io: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            data: *mut ::std::os::raw::c_void,
            size: usize,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Send a command to a node."]
    #[doc = ""]
    #[doc = " Upon completion, a command might change the state of a node."]
    #[doc = ""]
    #[doc = " This function must be called from the main thread."]
    #[doc = ""]
    #[doc = " \\param node a  spa_node"]
    #[doc = " \\param command a spa_command"]
    #[doc = " \\return 0 on success"]
    #[doc = "         -EINVAL when node or command is NULL"]
    #[doc = "         -ENOTSUP when this node can't process commands"]
    #[doc = "         -EINVAL \\a command is an invalid command"]
    pub send_command: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            command: *const spa_command,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Make a new port with \\a port_id. The caller should use the lowest unused"]
    #[doc = " port id for the given \\a direction."]
    #[doc = ""]
    #[doc = " Port ids should be between 0 and max_ports as obtained from the info"]
    #[doc = " event."]
    #[doc = ""]
    #[doc = " This function must be called from the main thread."]
    #[doc = ""]
    #[doc = " \\param node a  spa_node"]
    #[doc = " \\param direction a #enum spa_direction"]
    #[doc = " \\param port_id an unused port id"]
    #[doc = " \\param props extra properties"]
    #[doc = " \\return 0 on success"]
    #[doc = "         -EINVAL when node is NULL"]
    pub add_port: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            props: *const spa_dict,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Remove a port with \\a port_id."]
    #[doc = ""]
    #[doc = " \\param node a  spa_node"]
    #[doc = " \\param direction a #enum spa_direction"]
    #[doc = " \\param port_id a port id"]
    #[doc = " \\return 0 on success"]
    #[doc = "         -EINVAL when node is NULL or when port_id is unknown or"]
    #[doc = "\t\twhen the port can't be removed."]
    pub remove_port: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate all possible parameters of \\a id on \\a port_id of \\a node"]
    #[doc = " that are compatible with \\a filter."]
    #[doc = ""]
    #[doc = " The result parameters can be queried and modified and ultimately be used"]
    #[doc = " to call port_set_param."]
    #[doc = ""]
    #[doc = " The function will emit the result event up to \\a max times with"]
    #[doc = " the result value. The seq in the result event will either be the"]
    #[doc = " \\a seq number when executed synchronously or the async return"]
    #[doc = " value of this function when executed asynchronously."]
    #[doc = ""]
    #[doc = " This function must be called from the main thread."]
    #[doc = ""]
    #[doc = " \\param node a spa_node"]
    #[doc = " \\param seq a sequence number to pass to the result event when"]
    #[doc = "\tthis method is executed synchronously."]
    #[doc = " \\param direction an spa_direction"]
    #[doc = " \\param port_id the port to query"]
    #[doc = " \\param id the parameter id to query"]
    #[doc = " \\param start the first index to query, 0 to get the first item"]
    #[doc = " \\param max the maximum number of params to query"]
    #[doc = " \\param filter a parameter filter or NULL for no filter"]
    #[doc = ""]
    #[doc = " \\return 0 when no more items can be iterated."]
    #[doc = "         -EINVAL when invalid parameters are given"]
    #[doc = "         -ENOENT when \\a id is unknown"]
    #[doc = "         an async return value when the result event will be"]
    #[doc = "             emitted later."]
    pub port_enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            direction: spa_direction,
            port_id: u32,
            id: u32,
            start: u32,
            max: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set a parameter on \\a port_id of \\a node."]
    #[doc = ""]
    #[doc = " When \\a param is NULL, the parameter will be unset."]
    #[doc = ""]
    #[doc = " This function must be called from the main thread."]
    #[doc = ""]
    #[doc = " \\param node a #struct spa_node"]
    #[doc = " \\param direction a #enum spa_direction"]
    #[doc = " \\param port_id the port to configure"]
    #[doc = " \\param id the parameter id to set"]
    #[doc = " \\param flags optional flags"]
    #[doc = " \\param param a #struct spa_pod with the parameter to set"]
    #[doc = " \\return 0 on success"]
    #[doc = "         1 on success, the value of \\a param might have been"]
    #[doc = "                changed depending on \\a flags and the final value can be found by"]
    #[doc = "                doing port_enum_params."]
    #[doc = "         -EINVAL when node is NULL or invalid arguments are given"]
    #[doc = "         -ESRCH when one of the mandatory param"]
    #[doc = "                 properties is not specified and SPA_NODE_PARAM_FLAG_FIXATE was"]
    #[doc = "                 not set in \\a flags."]
    #[doc = "         -ESRCH when the type or size of a property is not correct."]
    #[doc = "         -ENOENT when the param id is not found"]
    pub port_set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Tell the port to use the given buffers"]
    #[doc = ""]
    #[doc = " When \\a flags contains SPA_NODE_BUFFERS_FLAG_ALLOC, the data"]
    #[doc = " in the buffers should point to an array of at least 1 data entry"]
    #[doc = " with the desired supported type that will be filled by this function."]
    #[doc = ""]
    #[doc = " The port should also have a spa_io_buffers io area configured to exchange"]
    #[doc = " the buffers with the port."]
    #[doc = ""]
    #[doc = " For an input port, all the buffers will remain dequeued."]
    #[doc = " Once a buffer has been queued on a port in the spa_io_buffers,"]
    #[doc = " it should not be reused until the reuse_buffer callback is notified"]
    #[doc = " or when the buffer has been returned in the spa_io_buffers of"]
    #[doc = " the port."]
    #[doc = ""]
    #[doc = " For output ports, all buffers will be queued in the port. When process"]
    #[doc = " returns SPA_STATUS_HAVE_DATA, buffers are available in one or more"]
    #[doc = " of the spa_io_buffers areas."]
    #[doc = ""]
    #[doc = " When a buffer can be reused, port_reuse_buffer() should be called or the"]
    #[doc = " buffer_id should be placed in the spa_io_buffers area before calling"]
    #[doc = " process."]
    #[doc = ""]
    #[doc = " Passing NULL as \\a buffers will remove the reference that the port has"]
    #[doc = " on the buffers."]
    #[doc = ""]
    #[doc = " When this function returns async, use the spa_node_sync operation to"]
    #[doc = " wait for completion."]
    #[doc = ""]
    #[doc = " This function must be called from the main thread."]
    #[doc = ""]
    #[doc = " \\param object an object implementing the interface"]
    #[doc = " \\param direction a port direction"]
    #[doc = " \\param port_id a port id"]
    #[doc = " \\param flags extra flags"]
    #[doc = " \\param buffers an array of buffer pointers"]
    #[doc = " \\param n_buffers number of elements in \\a buffers"]
    #[doc = " \\return 0 on success"]
    pub port_use_buffers: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            flags: u32,
            buffers: *mut *mut spa_buffer,
            n_buffers: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Configure the given memory area with \\a id on \\a port_id. This"]
    #[doc = " structure is allocated by the host and is used to exchange"]
    #[doc = " data and parameters with the port."]
    #[doc = ""]
    #[doc = " Setting an \\a io of NULL will disable the port io."]
    #[doc = ""]
    #[doc = " This function must be called from the main thread."]
    #[doc = ""]
    #[doc = " \\param direction a spa_direction"]
    #[doc = " \\param port_id a port id"]
    #[doc = " \\param id the id of the io area, the available ids can be"]
    #[doc = "        enumerated with the port parameters."]
    #[doc = " \\param data a io area memory"]
    #[doc = " \\param size the size of \\a data"]
    #[doc = " \\return 0 on success"]
    #[doc = "         -EINVAL when invalid input is given"]
    #[doc = "         -ENOENT when \\a id is unknown"]
    #[doc = "         -ENOSPC when \\a size is too small"]
    pub port_set_io: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            id: u32,
            data: *mut ::std::os::raw::c_void,
            size: usize,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Tell an output port to reuse a buffer."]
    #[doc = ""]
    #[doc = " This function must be called from the data thread."]
    #[doc = ""]
    #[doc = " \\param node a spa_node"]
    #[doc = " \\param port_id a port id"]
    #[doc = " \\param buffer_id a buffer id to reuse"]
    #[doc = " \\return 0 on success"]
    #[doc = "         -EINVAL when node is NULL"]
    pub port_reuse_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            port_id: u32,
            buffer_id: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Process the node"]
    #[doc = ""]
    #[doc = " This function must be called from the data thread."]
    #[doc = ""]
    #[doc = " Output io areas with SPA_STATUS_NEED_DATA will recycle the"]
    #[doc = " buffers if any."]
    #[doc = ""]
    #[doc = " Input areas with SPA_STATUS_HAVE_DATA are consumed if possible"]
    #[doc = " and the status is set to SPA_STATUS_NEED_DATA or SPA_STATUS_OK."]
    #[doc = ""]
    #[doc = " When the node has new output buffers, the SPA_STATUS_HAVE_DATA"]
    #[doc = " bit will be set."]
    #[doc = ""]
    #[doc = " When the node can accept new input in the next cycle, the"]
    #[doc = " SPA_STATUS_NEED_DATA bit will be set."]
    pub process: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
}
pub const PW_MEMBLOCK_FLAG_NONE: pw_memblock_flags = 0;
#[doc = "< memory is readable"]
pub const PW_MEMBLOCK_FLAG_READABLE: pw_memblock_flags = 1;
#[doc = "< memory is writable"]
pub const PW_MEMBLOCK_FLAG_WRITABLE: pw_memblock_flags = 2;
#[doc = "< seal the fd"]
pub const PW_MEMBLOCK_FLAG_SEAL: pw_memblock_flags = 4;
#[doc = "< mmap the fd"]
pub const PW_MEMBLOCK_FLAG_MAP: pw_memblock_flags = 8;
#[doc = "< don't close fd"]
pub const PW_MEMBLOCK_FLAG_DONT_CLOSE: pw_memblock_flags = 16;
#[doc = "< don't notify events"]
pub const PW_MEMBLOCK_FLAG_DONT_NOTIFY: pw_memblock_flags = 32;
pub const PW_MEMBLOCK_FLAG_READWRITE: pw_memblock_flags = 3;
#[doc = " Flags passed to \\ref pw_mempool_alloc() \\memberof pw_memblock"]
pub type pw_memblock_flags = ::std::os::raw::c_uint;
pub const PW_MEMMAP_FLAG_NONE: pw_memmap_flags = 0;
#[doc = "< map in read mode"]
pub const PW_MEMMAP_FLAG_READ: pw_memmap_flags = 1;
#[doc = "< map in write mode"]
pub const PW_MEMMAP_FLAG_WRITE: pw_memmap_flags = 2;
#[doc = "< map the same area twice after each other,"]
#[doc = "  creating a circular ringbuffer"]
pub const PW_MEMMAP_FLAG_TWICE: pw_memmap_flags = 4;
#[doc = "< writes will be private"]
pub const PW_MEMMAP_FLAG_PRIVATE: pw_memmap_flags = 8;
#[doc = "< lock the memory into RAM"]
pub const PW_MEMMAP_FLAG_LOCKED: pw_memmap_flags = 16;
pub const PW_MEMMAP_FLAG_READWRITE: pw_memmap_flags = 3;
pub type pw_memmap_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_memchunk {
    _unused: [u8; 0],
}
#[doc = " \\class pw_memblock"]
#[doc = ""]
#[doc = " A memory pool is a collection of pw_memblocks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_mempool {
    pub props: *mut pw_properties,
}
#[doc = " \\class pw_memblock"]
#[doc = " Memory block structure"]
#[repr(C)]
pub struct pw_memblock {
    #[doc = "< owner pool"]
    pub pool: *mut pw_mempool,
    #[doc = "< unique id"]
    pub id: u32,
    #[doc = "< refcount"]
    pub ref_: ::std::os::raw::c_int,
    #[doc = "< flags for the memory block on of enum pw_memblock_flags"]
    pub flags: u32,
    #[doc = "< type of the fd, one of enum spa_data_type"]
    pub type_: u32,
    #[doc = "< fd"]
    pub fd: ::std::os::raw::c_int,
    #[doc = "< size of memory"]
    pub size: u32,
    #[doc = "< optional map when PW_MEMBLOCK_FLAG_MAP was given"]
    pub map: *mut pw_memmap,
}
#[doc = " a mapped region of a pw_memblock"]
#[repr(C)]
pub struct pw_memmap {
    #[doc = "< owner memblock"]
    pub block: *mut pw_memblock,
    #[doc = "< mapped pointer"]
    pub ptr: *mut ::std::os::raw::c_void,
    #[doc = "< flags for the mapping on of enum pw_memmap_flags"]
    pub flags: u32,
    #[doc = "< offset in memblock"]
    pub offset: u32,
    #[doc = "< size in memblock"]
    pub size: u32,
    #[doc = "< user tag"]
    pub tag: [u32; 5usize],
}
#[repr(C)]
pub struct pw_mempool_events {
    pub version: u32,
    #[doc = " the pool is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " a new memory block is added to the pool"]
    pub added: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, block: *mut pw_memblock),
    >,
    #[doc = " a memory block is removed from the pool"]
    pub removed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, block: *mut pw_memblock),
    >,
}
extern "C" {
    #[doc = " Create a new memory pool"]
    pub fn pw_mempool_new(props: *mut pw_properties) -> *mut pw_mempool;
}
extern "C" {
    #[doc = " Listen for events"]
    pub fn pw_mempool_add_listener(
        pool: *mut pw_mempool,
        listener: *mut spa_hook,
        events: *const pw_mempool_events,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Clear a pool"]
    pub fn pw_mempool_clear(pool: *mut pw_mempool);
}
extern "C" {
    #[doc = " Clear and destroy a pool"]
    pub fn pw_mempool_destroy(pool: *mut pw_mempool);
}
extern "C" {
    #[doc = " Allocate a memory block from the pool"]
    pub fn pw_mempool_alloc(
        pool: *mut pw_mempool,
        flags: pw_memblock_flags,
        type_: u32,
        size: usize,
    ) -> *mut pw_memblock;
}
extern "C" {
    #[doc = " Import a block from another pool"]
    pub fn pw_mempool_import_block(
        pool: *mut pw_mempool,
        mem: *mut pw_memblock,
    ) -> *mut pw_memblock;
}
extern "C" {
    #[doc = " Import an fd into the pool"]
    pub fn pw_mempool_import(
        pool: *mut pw_mempool,
        flags: pw_memblock_flags,
        type_: u32,
        fd: ::std::os::raw::c_int,
    ) -> *mut pw_memblock;
}
extern "C" {
    #[doc = " Free a memblock regardless of the refcount and destroy all mappings"]
    pub fn pw_memblock_free(mem: *mut pw_memblock);
}
extern "C" {
    #[doc = " Remove a memblock for given \\a id"]
    pub fn pw_mempool_remove_id(pool: *mut pw_mempool, id: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find memblock for given \\a ptr"]
    pub fn pw_mempool_find_ptr(
        pool: *mut pw_mempool,
        ptr: *const ::std::os::raw::c_void,
    ) -> *mut pw_memblock;
}
extern "C" {
    #[doc = " Find memblock for given \\a id"]
    pub fn pw_mempool_find_id(pool: *mut pw_mempool, id: u32) -> *mut pw_memblock;
}
extern "C" {
    #[doc = " Find memblock for given \\a fd"]
    pub fn pw_mempool_find_fd(pool: *mut pw_mempool, fd: ::std::os::raw::c_int)
        -> *mut pw_memblock;
}
extern "C" {
    #[doc = " Map a region of a memory block"]
    pub fn pw_memblock_map(
        block: *mut pw_memblock,
        flags: pw_memmap_flags,
        offset: u32,
        size: u32,
        tag: *mut u32,
    ) -> *mut pw_memmap;
}
extern "C" {
    #[doc = " Map a region of a memory block with \\a id"]
    pub fn pw_mempool_map_id(
        pool: *mut pw_mempool,
        id: u32,
        flags: pw_memmap_flags,
        offset: u32,
        size: u32,
        tag: *mut u32,
    ) -> *mut pw_memmap;
}
extern "C" {
    pub fn pw_mempool_import_map(
        pool: *mut pw_mempool,
        other: *mut pw_mempool,
        data: *mut ::std::os::raw::c_void,
        size: u32,
        tag: *mut u32,
    ) -> *mut pw_memmap;
}
extern "C" {
    #[doc = " find a map with the given tag"]
    pub fn pw_mempool_find_tag(pool: *mut pw_mempool, tag: *mut u32, size: usize)
        -> *mut pw_memmap;
}
extern "C" {
    #[doc = " Unmap a region"]
    pub fn pw_memmap_free(map: *mut pw_memmap) -> ::std::os::raw::c_int;
}
#[doc = " parameters to map a memory range"]
#[repr(C)]
pub struct pw_map_range {
    pub start: u32,
    #[doc = " offset in first page with start of data"]
    pub offset: u32,
    #[doc = " page aligned offset to map"]
    pub size: u32,
}
#[repr(C)]
pub struct pw_buffers {
    #[doc = "< allocated buffer memory"]
    pub mem: *mut pw_memblock,
    #[doc = "< port buffers"]
    pub buffers: *mut *mut spa_buffer,
    #[doc = "< number of port buffers"]
    pub n_buffers: u32,
    #[doc = "< flags"]
    pub flags: u32,
}
extern "C" {
    pub fn pw_buffers_negotiate(
        context: *mut pw_context,
        flags: u32,
        outnode: *mut spa_node,
        out_port_id: u32,
        innode: *mut spa_node,
        in_port_id: u32,
        result: *mut pw_buffers,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pw_buffers_clear(buffers: *mut pw_buffers);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_factory {
    _unused: [u8; 0],
}
#[doc = " The factory information. Extra information can be added in later versions \\memberof pw_introspect"]
#[repr(C)]
pub struct pw_factory_info {
    #[doc = "< id of the global"]
    pub id: u32,
    #[doc = "< name the factory"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< type of the objects created by this factory"]
    pub type_: *const ::std::os::raw::c_char,
    #[doc = "< version of the objects"]
    pub version: u32,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< the properties of the factory"]
    pub props: *mut spa_dict,
}
extern "C" {
    pub fn pw_factory_info_update(
        info: *mut pw_factory_info,
        update: *const pw_factory_info,
    ) -> *mut pw_factory_info;
}
extern "C" {
    pub fn pw_factory_info_free(info: *mut pw_factory_info);
}
#[doc = " Factory events"]
#[repr(C)]
pub struct pw_factory_events {
    pub version: u32,
    #[doc = " Notify factory info"]
    #[doc = ""]
    #[doc = " \\param info info about the factory"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void, info: *const pw_factory_info),
    >,
}
#[doc = " Factory methods"]
#[repr(C)]
pub struct pw_factory_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_factory_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
pub const SPA_LOG_LEVEL_NONE: spa_log_level = 0;
pub const SPA_LOG_LEVEL_ERROR: spa_log_level = 1;
pub const SPA_LOG_LEVEL_WARN: spa_log_level = 2;
pub const SPA_LOG_LEVEL_INFO: spa_log_level = 3;
pub const SPA_LOG_LEVEL_DEBUG: spa_log_level = 4;
pub const SPA_LOG_LEVEL_TRACE: spa_log_level = 5;
pub type spa_log_level = ::std::os::raw::c_uint;
#[repr(C)]
pub struct spa_log {
    #[doc = " the version of this log. This can be used to expand this"]
    #[doc = " structure in the future"]
    pub iface: spa_interface,
    #[doc = " Logging level, everything above this level is not logged"]
    pub level: spa_log_level,
}
#[repr(C)]
pub struct spa_log_methods {
    pub version: u32,
    #[doc = " Log a message with the given log level."]
    #[doc = ""]
    #[doc = " \\param log a spa_log"]
    #[doc = " \\param level a spa_log_level"]
    #[doc = " \\param file the file name"]
    #[doc = " \\param line the line number"]
    #[doc = " \\param func the function name"]
    #[doc = " \\param fmt printf style format"]
    #[doc = " \\param ... format arguments"]
    pub log: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            level: spa_log_level,
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            func: *const ::std::os::raw::c_char,
            fmt: *const ::std::os::raw::c_char,
            ...
        ),
    >,
    #[doc = " Log a message with the given log level."]
    #[doc = ""]
    #[doc = " \\param log a spa_log"]
    #[doc = " \\param level a spa_log_level"]
    #[doc = " \\param file the file name"]
    #[doc = " \\param line the line number"]
    #[doc = " \\param func the function name"]
    #[doc = " \\param fmt printf style format"]
    #[doc = " \\param args format arguments"]
    pub logv: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            level: spa_log_level,
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            func: *const ::std::os::raw::c_char,
            fmt: *const ::std::os::raw::c_char,
            args: *mut __va_list_tag,
        ),
    >,
}
extern "C" {
    #[doc = " Configure a logging module. This is usually done automatically"]
    #[doc = " in pw_init() but you can install a custom logger before calling"]
    #[doc = " pw_init()."]
    pub fn pw_log_set(log: *mut spa_log);
}
extern "C" {
    #[doc = " Get the log interface"]
    pub fn pw_log_get() -> *mut spa_log;
}
extern "C" {
    #[doc = " Configure the logging level"]
    pub fn pw_log_set_level(level: spa_log_level);
}
extern "C" {
    #[doc = " Log a message"]
    pub fn pw_log_log(
        level: spa_log_level,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Log a message"]
    pub fn pw_log_logv(
        level: spa_log_level,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_link {
    _unused: [u8; 0],
}
#[doc = "< the link is in error"]
pub const PW_LINK_STATE_ERROR: pw_link_state = -2;
#[doc = "< the link is unlinked"]
pub const PW_LINK_STATE_UNLINKED: pw_link_state = -1;
#[doc = "< the link is initialized"]
pub const PW_LINK_STATE_INIT: pw_link_state = 0;
#[doc = "< the link is negotiating formats"]
pub const PW_LINK_STATE_NEGOTIATING: pw_link_state = 1;
#[doc = "< the link is allocating buffers"]
pub const PW_LINK_STATE_ALLOCATING: pw_link_state = 2;
#[doc = "< the link is paused"]
pub const PW_LINK_STATE_PAUSED: pw_link_state = 3;
#[doc = "< the link is active"]
pub const PW_LINK_STATE_ACTIVE: pw_link_state = 4;
#[doc = " \\enum pw_link_state The different link states \\memberof pw_link"]
pub type pw_link_state = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Convert a \\ref pw_link_state to a readable string \\memberof pw_link"]
    pub fn pw_link_state_as_string(state: pw_link_state) -> *const ::std::os::raw::c_char;
}
#[doc = " The link information. Extra information can be added in later versions \\memberof pw_introspect"]
#[repr(C)]
pub struct pw_link_info {
    #[doc = "< id of the global"]
    pub id: u32,
    #[doc = "< server side output node id"]
    pub output_node_id: u32,
    #[doc = "< output port id"]
    pub output_port_id: u32,
    #[doc = "< server side input node id"]
    pub input_node_id: u32,
    #[doc = "< input port id"]
    pub input_port_id: u32,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< the current state of the link"]
    pub state: pw_link_state,
    #[doc = "< an error reason if \\a state is error"]
    pub error: *const ::std::os::raw::c_char,
    #[doc = "< format over link"]
    pub format: *mut spa_pod,
    #[doc = "< the properties of the link"]
    pub props: *mut spa_dict,
}
extern "C" {
    pub fn pw_link_info_update(
        info: *mut pw_link_info,
        update: *const pw_link_info,
    ) -> *mut pw_link_info;
}
extern "C" {
    pub fn pw_link_info_free(info: *mut pw_link_info);
}
#[doc = " Link events"]
#[repr(C)]
pub struct pw_link_events {
    pub version: u32,
    #[doc = " Notify link info"]
    #[doc = ""]
    #[doc = " \\param info info about the link"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void, info: *const pw_link_info),
    >,
}
#[doc = " Link methods"]
#[repr(C)]
pub struct pw_link_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_link_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = " \\class pw_main_loop"]
#[doc = ""]
#[doc = " \\brief PipeWire main-loop interface."]
#[doc = ""]
#[doc = " A main loop object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_main_loop {
    _unused: [u8; 0],
}
#[doc = " Events of the main loop"]
#[repr(C)]
pub struct pw_main_loop_events {
    pub version: u32,
    #[doc = " Emitted when the main loop is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
extern "C" {
    #[doc = " Create a new main loop."]
    pub fn pw_main_loop_new(props: *const spa_dict) -> *mut pw_main_loop;
}
extern "C" {
    #[doc = " Add an event listener"]
    pub fn pw_main_loop_add_listener(
        loop_: *mut pw_main_loop,
        listener: *mut spa_hook,
        events: *const pw_main_loop_events,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Get the loop implementation"]
    pub fn pw_main_loop_get_loop(loop_: *mut pw_main_loop) -> *mut pw_loop;
}
extern "C" {
    #[doc = " Destroy a loop"]
    pub fn pw_main_loop_destroy(loop_: *mut pw_main_loop);
}
extern "C" {
    #[doc = " Run a main loop. This blocks until \\ref pw_main_loop_quit is called"]
    pub fn pw_main_loop_run(loop_: *mut pw_main_loop) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Quit a main loop"]
    pub fn pw_main_loop_quit(loop_: *mut pw_main_loop) -> ::std::os::raw::c_int;
}
#[doc = " An entry in the map \\memberof pw_map"]
#[repr(C)]
pub struct pw_map_item {
    #[doc = "< next free index"]
    pub next: __BindgenUnionField<u32>,
    #[doc = "< data of this item, must be an even address"]
    pub data: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub bindgen_union_field: u64,
}
#[doc = " A map \\memberof pw_map"]
#[repr(C)]
pub struct pw_map {
    #[doc = "< an array with the map items"]
    pub items: pw_array,
    #[doc = "< the free items"]
    pub free_list: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_module {
    _unused: [u8; 0],
}
#[doc = " The module information. Extra information can be added in later versions \\memberof pw_introspect"]
#[repr(C)]
pub struct pw_module_info {
    #[doc = "< id of the global"]
    pub id: u32,
    #[doc = "< name of the module"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< filename of the module"]
    pub filename: *const ::std::os::raw::c_char,
    #[doc = "< arguments passed to the module"]
    pub args: *const ::std::os::raw::c_char,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< extra properties"]
    pub props: *mut spa_dict,
}
extern "C" {
    #[doc = " Update and existing \\ref pw_module_info with \\a update \\memberof pw_introspect"]
    pub fn pw_module_info_update(
        info: *mut pw_module_info,
        update: *const pw_module_info,
    ) -> *mut pw_module_info;
}
extern "C" {
    #[doc = " Free a \\ref pw_module_info \\memberof pw_introspect"]
    pub fn pw_module_info_free(info: *mut pw_module_info);
}
#[doc = " Module events"]
#[repr(C)]
pub struct pw_module_events {
    pub version: u32,
    #[doc = " Notify module info"]
    #[doc = ""]
    #[doc = " \\param info info about the module"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void, info: *const pw_module_info),
    >,
}
#[doc = " Module methods"]
#[repr(C)]
pub struct pw_module_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_module_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_node {
    _unused: [u8; 0],
}
#[doc = "< error state"]
pub const PW_NODE_STATE_ERROR: pw_node_state = -1;
#[doc = "< the node is being created"]
pub const PW_NODE_STATE_CREATING: pw_node_state = 0;
#[doc = "< the node is suspended, the device might"]
#[doc = "   be closed"]
pub const PW_NODE_STATE_SUSPENDED: pw_node_state = 1;
#[doc = "< the node is running but there is no active"]
#[doc = "   port"]
pub const PW_NODE_STATE_IDLE: pw_node_state = 2;
#[doc = "< the node is running"]
pub const PW_NODE_STATE_RUNNING: pw_node_state = 3;
#[doc = " \\enum pw_node_state The different node states \\memberof pw_node"]
pub type pw_node_state = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Convert a \\ref pw_node_state to a readable string \\memberof pw_node"]
    pub fn pw_node_state_as_string(state: pw_node_state) -> *const ::std::os::raw::c_char;
}
#[doc = " The node information. Extra information can be added in later versions \\memberof pw_introspect"]
#[repr(C)]
pub struct pw_node_info {
    #[doc = "< id of the global"]
    pub id: u32,
    #[doc = "< maximum number of inputs"]
    pub max_input_ports: u32,
    #[doc = "< maximum number of outputs"]
    pub max_output_ports: u32,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< number of inputs"]
    pub n_input_ports: u32,
    #[doc = "< number of outputs"]
    pub n_output_ports: u32,
    #[doc = "< the current state of the node"]
    pub state: pw_node_state,
    #[doc = "< an error reason if \\a state is error"]
    pub error: *const ::std::os::raw::c_char,
    #[doc = "< the properties of the node"]
    pub props: *mut spa_dict,
    #[doc = "< parameters"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
extern "C" {
    pub fn pw_node_info_update(
        info: *mut pw_node_info,
        update: *const pw_node_info,
    ) -> *mut pw_node_info;
}
extern "C" {
    pub fn pw_node_info_free(info: *mut pw_node_info);
}
#[doc = " Node events"]
#[repr(C)]
pub struct pw_node_events {
    pub version: u32,
    #[doc = " Notify node info"]
    #[doc = ""]
    #[doc = " \\param info info about the node"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void, info: *const pw_node_info),
    >,
    #[doc = " Notify a node param"]
    #[doc = ""]
    #[doc = " Event emitted as a result of the enum_params method."]
    #[doc = ""]
    #[doc = " \\param seq the sequence number of the request"]
    #[doc = " \\param id the param id"]
    #[doc = " \\param index the param index"]
    #[doc = " \\param next the param index of the next param"]
    #[doc = " \\param param the parameter"]
    pub param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            index: u32,
            next: u32,
            param: *const spa_pod,
        ),
    >,
}
#[doc = " Node methods"]
#[repr(C)]
pub struct pw_node_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_node_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Subscribe to parameter changes"]
    #[doc = ""]
    #[doc = " Automatically emit param events for the given ids when"]
    #[doc = " they are changed."]
    #[doc = ""]
    #[doc = " \\param ids an array of param ids"]
    #[doc = " \\param n_ids the number of ids in \\a ids"]
    pub subscribe_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            ids: *mut u32,
            n_ids: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate node parameters"]
    #[doc = ""]
    #[doc = " Start enumeration of node parameters. For each param, a"]
    #[doc = " param event will be emitted."]
    #[doc = ""]
    #[doc = " \\param seq a sequence number to place in the reply"]
    #[doc = " \\param id the parameter id to enum or PW_ID_ANY for all"]
    #[doc = " \\param start the start index or 0 for the first param"]
    #[doc = " \\param num the maximum number of params to retrieve"]
    #[doc = " \\param filter a param filter or NULL"]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            start: u32,
            num: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set a parameter on the node"]
    #[doc = ""]
    #[doc = " \\param id the parameter id to set"]
    #[doc = " \\param flags extra parameter flags"]
    #[doc = " \\param param the parameter to set"]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Send a command to the node"]
    #[doc = ""]
    #[doc = " \\param command the command to send"]
    pub send_command: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            command: *const spa_command,
        ) -> ::std::os::raw::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_port {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Convert a \\ref pw_direction to a readable string \\memberof pw_introspect"]
    pub fn pw_direction_as_string(direction: spa_direction) -> *const ::std::os::raw::c_char;
}
#[doc = " \\class pw_introspect"]
#[doc = ""]
#[doc = " The introspection methods and structures are used to get information"]
#[doc = " about the object in the PipeWire server"]
#[repr(C)]
pub struct pw_port_info {
    #[doc = "< id of the global"]
    pub id: u32,
    #[doc = "< port direction"]
    pub direction: spa_direction,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< the properties of the port"]
    pub props: *mut spa_dict,
    #[doc = "< parameters"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
extern "C" {
    pub fn pw_port_info_update(
        info: *mut pw_port_info,
        update: *const pw_port_info,
    ) -> *mut pw_port_info;
}
extern "C" {
    pub fn pw_port_info_free(info: *mut pw_port_info);
}
#[doc = " Port events"]
#[repr(C)]
pub struct pw_port_events {
    pub version: u32,
    #[doc = " Notify port info"]
    #[doc = ""]
    #[doc = " \\param info info about the port"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void, info: *const pw_port_info),
    >,
    #[doc = " Notify a port param"]
    #[doc = ""]
    #[doc = " Event emitted as a result of the enum_params method."]
    #[doc = ""]
    #[doc = " \\param seq the sequence number of the request"]
    #[doc = " \\param id the param id"]
    #[doc = " \\param index the param index"]
    #[doc = " \\param next the param index of the next param"]
    #[doc = " \\param param the parameter"]
    pub param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            index: u32,
            next: u32,
            param: *const spa_pod,
        ),
    >,
}
#[doc = " Port methods"]
#[repr(C)]
pub struct pw_port_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_port_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Subscribe to parameter changes"]
    #[doc = ""]
    #[doc = " Automatically emit param events for the given ids when"]
    #[doc = " they are changed."]
    #[doc = ""]
    #[doc = " \\param ids an array of param ids"]
    #[doc = " \\param n_ids the number of ids in \\a ids"]
    pub subscribe_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            ids: *mut u32,
            n_ids: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate port parameters"]
    #[doc = ""]
    #[doc = " Start enumeration of port parameters. For each param, a"]
    #[doc = " param event will be emitted."]
    #[doc = ""]
    #[doc = " \\param seq a sequence number returned in the reply"]
    #[doc = " \\param id the parameter id to enumerate"]
    #[doc = " \\param start the start index or 0 for the first param"]
    #[doc = " \\param num the maximum number of params to retrieve"]
    #[doc = " \\param filter a param filter or NULL"]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            start: u32,
            num: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
}
#[doc = " \\page page_streams Media Streams"]
#[doc = ""]
#[doc = " \\section sec_overview Overview"]
#[doc = ""]
#[doc = " Media streams are used to exchange data with the PipeWire server. A"]
#[doc = " stream is a wrapper around a proxy for a \\ref pw_client_node with"]
#[doc = " an adapter. This means the stream will automatically do conversion"]
#[doc = " to the type required by the server."]
#[doc = ""]
#[doc = " Streams can be used to:"]
#[doc = ""]
#[doc = " \\li Consume a stream from PipeWire. This is a PW_DIRECTION_INPUT stream."]
#[doc = " \\li Produce a stream to PipeWire. This is a PW_DIRECTION_OUTPUT stream"]
#[doc = ""]
#[doc = " You can connect the stream port to a specific server port or let PipeWire"]
#[doc = " choose a port for you."]
#[doc = ""]
#[doc = " For more complicated nodes such as filters or ports with multiple"]
#[doc = " inputs and/or outputs you will need to use the pw_filter or make"]
#[doc = " a pw_node yourself and export it with \\ref pw_core_export."]
#[doc = ""]
#[doc = " \\section sec_create Create"]
#[doc = ""]
#[doc = " Make a new stream with \\ref pw_stream_new(). You will need to specify"]
#[doc = " a name for the stream and extra properties. You can use \\ref"]
#[doc = " pw_fill_stream_properties() to get a basic set of properties for the"]
#[doc = " stream."]
#[doc = ""]
#[doc = " Once the stream is created, the state_changed event should be used to"]
#[doc = " track the state of the stream."]
#[doc = ""]
#[doc = " \\section sec_connect Connect"]
#[doc = ""]
#[doc = " The stream is initially unconnected. To connect the stream, use"]
#[doc = " \\ref pw_stream_connect(). Pass the desired direction as an argument."]
#[doc = ""]
#[doc = " \\subsection ssec_stream_target Stream target"]
#[doc = ""]
#[doc = " To make the newly connected stream automatically connect to an existing"]
#[doc = " PipeWire node, use the \\ref PW_STREAM_FLAG_AUTOCONNECT and the port_path"]
#[doc = " argument while connecting."]
#[doc = ""]
#[doc = " \\subsection ssec_stream_formats Stream formats"]
#[doc = ""]
#[doc = " An array of possible formats that this stream can consume or provide"]
#[doc = " must be specified."]
#[doc = ""]
#[doc = " \\section sec_format Format negotiation"]
#[doc = ""]
#[doc = " After connecting the stream, the server will want to configure some"]
#[doc = " parameters on the stream. You will be notified of these changes"]
#[doc = " with the param_changed event."]
#[doc = ""]
#[doc = " When a format param change is emitted, the client should now prepare"]
#[doc = " itself to deal with the format and complete the negotiation procedure"]
#[doc = " with a call to \\ref pw_stream_update_params()."]
#[doc = ""]
#[doc = " As arguments to \\ref pw_stream_update_params() an array of spa_param"]
#[doc = " structures must be given. They contain parameters such as buffer size,"]
#[doc = " number of buffers, required metadata and other parameters for the"]
#[doc = " media buffers."]
#[doc = ""]
#[doc = " \\section sec_buffers Buffer negotiation"]
#[doc = ""]
#[doc = " After completing the format negotiation, PipeWire will allocate and"]
#[doc = " notify the stream of the buffers that will be used to exchange data"]
#[doc = " between client and server."]
#[doc = ""]
#[doc = " With the add_buffer event, a stream will be notified of a new buffer"]
#[doc = " that can be used for data transport. You can attach user_data to these"]
#[doc = " buffers."]
#[doc = ""]
#[doc = " After the buffers are negotiated, the stream will transition to the"]
#[doc = " \\ref PW_STREAM_STATE_PAUSED state."]
#[doc = ""]
#[doc = " \\section sec_streaming Streaming"]
#[doc = ""]
#[doc = " From the \\ref PW_STREAM_STATE_PAUSED state, the stream can be set to"]
#[doc = " the \\ref PW_STREAM_STATE_STREAMING state by the PipeWire server when"]
#[doc = " data transport is started."]
#[doc = ""]
#[doc = " Depending on how the stream was connected it will need to Produce or"]
#[doc = " Consume data for/from PipeWire as explained in the following"]
#[doc = " subsections."]
#[doc = ""]
#[doc = " \\subsection ssec_consume Consume data"]
#[doc = ""]
#[doc = " The process event is emitted for each new buffer that can can be"]
#[doc = " consumed."]
#[doc = ""]
#[doc = " \\ref pw_stream_dequeue_buffer() should be used to get the data and"]
#[doc = " metadata of the buffer."]
#[doc = ""]
#[doc = " When the buffer is no longer in use, call \\ref pw_stream_queue_buffer()"]
#[doc = " to let PipeWire reuse the buffer."]
#[doc = ""]
#[doc = " \\subsection ssec_produce Produce data"]
#[doc = ""]
#[doc = " \\ref pw_stream_dequeue_buffer() gives an empty buffer that can be filled."]
#[doc = ""]
#[doc = " Filled buffers should be queued with \\ref pw_stream_queue_buffer()."]
#[doc = ""]
#[doc = " The process event is emitted when PipeWire has emptied a buffer that"]
#[doc = " can now be refilled."]
#[doc = ""]
#[doc = " \\section sec_stream_disconnect Disconnect"]
#[doc = ""]
#[doc = " Use \\ref pw_stream_disconnect() to disconnect a stream after use."]
#[doc = ""]
#[doc = " \\brief PipeWire stream object class"]
#[doc = ""]
#[doc = " The stream object provides a convenient way to send and"]
#[doc = " receive data streams from/to PipeWire."]
#[doc = ""]
#[doc = " See also \\ref page_streams and \\ref page_context_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_stream {
    _unused: [u8; 0],
}
#[doc = "< the stream is in error"]
pub const PW_STREAM_STATE_ERROR: pw_stream_state = -1;
#[doc = "< unconnected"]
pub const PW_STREAM_STATE_UNCONNECTED: pw_stream_state = 0;
#[doc = "< connection is in progress"]
pub const PW_STREAM_STATE_CONNECTING: pw_stream_state = 1;
#[doc = "< paused"]
pub const PW_STREAM_STATE_PAUSED: pw_stream_state = 2;
#[doc = "< streaming"]
pub const PW_STREAM_STATE_STREAMING: pw_stream_state = 3;
#[doc = " \\enum pw_stream_state The state of a stream \\memberof pw_stream"]
pub type pw_stream_state = ::std::os::raw::c_int;
#[repr(C)]
pub struct pw_buffer {
    #[doc = "< the spa buffer"]
    pub buffer: *mut spa_buffer,
    #[doc = "< user data attached to the buffer"]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = "< This field is set by the user and the sum of"]
    #[doc = "  all queued buffer is returned in the time info"]
    pub size: u64,
}
#[repr(C)]
pub struct pw_stream_control {
    #[doc = "< name of the control"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< extra flags (unused)"]
    pub flags: u32,
    #[doc = "< default value"]
    pub def: f32,
    #[doc = "< min value"]
    pub min: f32,
    #[doc = "< max value"]
    pub max: f32,
    #[doc = "< array of values"]
    pub values: *mut f32,
    #[doc = "< number of values in array"]
    pub n_values: u32,
    #[doc = "< max values that can be set on this control"]
    pub max_values: u32,
}
#[doc = " A time structure \\memberof pw_stream"]
#[repr(C)]
pub struct pw_time {
    #[doc = "< the monotonic time in nanoseconds"]
    pub now: i64,
    #[doc = "< the rate of \\a ticks and delay"]
    pub rate: spa_fraction,
    #[doc = "< the ticks at \\a now. This is the current time that"]
    #[doc = "  the remote end is reading/writing."]
    pub ticks: u64,
    #[doc = "< delay to device, add to ticks to get the time of the"]
    #[doc = "  device. Positive for INPUT streams and"]
    #[doc = "  negative for OUTPUT streams."]
    pub delay: i64,
    #[doc = "< data queued in the stream, this is the sum"]
    #[doc = "  of the size fields in the pw_buffer that are"]
    #[doc = "  currently queued"]
    pub queued: u64,
}
#[doc = " Events for a stream. These events are always called from the mainloop"]
#[doc = " unless explicitly documented otherwise."]
#[repr(C)]
pub struct pw_stream_events {
    pub version: u32,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " when the stream state changes"]
    pub state_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            old: pw_stream_state,
            state: pw_stream_state,
            error: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " Notify information about a control."]
    pub control_info: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            control: *const pw_stream_control,
        ),
    >,
    #[doc = " when io changed on the stream."]
    pub io_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            area: *mut ::std::os::raw::c_void,
            size: u32,
        ),
    >,
    #[doc = " when a parameter changed"]
    pub param_changed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, id: u32, param: *const spa_pod),
    >,
    #[doc = " when a new buffer was created for this stream"]
    pub add_buffer: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, buffer: *mut pw_buffer),
    >,
    #[doc = " when a buffer was destroyed for this stream"]
    pub remove_buffer: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, buffer: *mut pw_buffer),
    >,
    #[doc = " when a buffer can be queued (for playback streams) or"]
    #[doc = "  dequeued (for capture streams). This is normally called from the"]
    #[doc = "  mainloop but can also be called directly from the realtime data"]
    #[doc = "  thread if the user is prepared to deal with this."]
    pub process: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " The stream is drained"]
    pub drained: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
extern "C" {
    #[doc = " Convert a stream state to a readable string \\memberof pw_stream"]
    pub fn pw_stream_state_as_string(state: pw_stream_state) -> *const ::std::os::raw::c_char;
}
#[doc = "< no flags"]
pub const PW_STREAM_FLAG_NONE: pw_stream_flags = 0;
#[doc = "< try to automatically connect"]
#[doc = "  this stream"]
pub const PW_STREAM_FLAG_AUTOCONNECT: pw_stream_flags = 1;
#[doc = "< start the stream inactive,"]
#[doc = "  pw_stream_set_active() needs to be"]
#[doc = "  called explicitly"]
pub const PW_STREAM_FLAG_INACTIVE: pw_stream_flags = 2;
#[doc = "< mmap the buffers except DmaBuf"]
pub const PW_STREAM_FLAG_MAP_BUFFERS: pw_stream_flags = 4;
#[doc = "< be a driver"]
pub const PW_STREAM_FLAG_DRIVER: pw_stream_flags = 8;
#[doc = "< call process from the realtime"]
#[doc = "  thread. You MUST use RT safe functions"]
#[doc = "  in the process callback."]
pub const PW_STREAM_FLAG_RT_PROCESS: pw_stream_flags = 16;
#[doc = "< don't convert format"]
pub const PW_STREAM_FLAG_NO_CONVERT: pw_stream_flags = 32;
#[doc = "< require exclusive access to the"]
#[doc = "  device"]
pub const PW_STREAM_FLAG_EXCLUSIVE: pw_stream_flags = 64;
#[doc = "< don't try to reconnect this stream"]
#[doc = "  when the sink/source is removed"]
pub const PW_STREAM_FLAG_DONT_RECONNECT: pw_stream_flags = 128;
#[doc = "< the application will allocate buffer"]
#[doc = "  memory. In the add_buffer event, the"]
#[doc = "  data of the buffer should be set"]
pub const PW_STREAM_FLAG_ALLOC_BUFFERS: pw_stream_flags = 256;
#[doc = " \\enum pw_stream_flags Extra flags that can be used in \\ref pw_stream_connect() \\memberof pw_stream"]
pub type pw_stream_flags = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Create a new unconneced \\ref pw_stream \\memberof pw_stream"]
    #[doc = " \\return a newly allocated \\ref pw_stream"]
    pub fn pw_stream_new(
        core: *mut pw_core,
        name: *const ::std::os::raw::c_char,
        props: *mut pw_properties,
    ) -> *mut pw_stream;
}
extern "C" {
    pub fn pw_stream_new_simple(
        loop_: *mut pw_loop,
        name: *const ::std::os::raw::c_char,
        props: *mut pw_properties,
        events: *const pw_stream_events,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut pw_stream;
}
extern "C" {
    #[doc = " Destroy a stream \\memberof pw_stream"]
    pub fn pw_stream_destroy(stream: *mut pw_stream);
}
extern "C" {
    pub fn pw_stream_add_listener(
        stream: *mut pw_stream,
        listener: *mut spa_hook,
        events: *const pw_stream_events,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pw_stream_get_state(
        stream: *mut pw_stream,
        error: *mut *const ::std::os::raw::c_char,
    ) -> pw_stream_state;
}
extern "C" {
    pub fn pw_stream_get_name(stream: *mut pw_stream) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pw_stream_get_core(stream: *mut pw_stream) -> *mut pw_core;
}
extern "C" {
    pub fn pw_stream_get_properties(stream: *mut pw_stream) -> *const pw_properties;
}
extern "C" {
    pub fn pw_stream_update_properties(
        stream: *mut pw_stream,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Connect a stream for input or output on \\a port_path. \\memberof pw_stream"]
    #[doc = " \\return 0 on success < 0 on error."]
    #[doc = ""]
    #[doc = " You should connect to the process event and use pw_stream_dequeue_buffer()"]
    #[doc = " to get the latest metadata and data."]
    pub fn pw_stream_connect(
        stream: *mut pw_stream,
        direction: spa_direction,
        target_id: u32,
        flags: pw_stream_flags,
        params: *mut *const spa_pod,
        n_params: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the node ID of the stream. \\memberof pw_stream"]
    #[doc = " \\return node ID."]
    pub fn pw_stream_get_node_id(stream: *mut pw_stream) -> u32;
}
extern "C" {
    #[doc = " Disconnect \\a stream \\memberof pw_stream"]
    pub fn pw_stream_disconnect(stream: *mut pw_stream) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the stream in error state"]
    pub fn pw_stream_set_error(
        stream: *mut pw_stream,
        res: ::std::os::raw::c_int,
        error: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Complete the negotiation process with result code \\a res \\memberof pw_stream"]
    #[doc = ""]
    #[doc = " This function should be called after notification of the format."]
    #[doc = ""]
    #[doc = " When \\a res indicates success, \\a params contain the parameters for the"]
    #[doc = " allocation state."]
    pub fn pw_stream_update_params(
        stream: *mut pw_stream,
        params: *mut *const spa_pod,
        n_params: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set control values"]
    pub fn pw_stream_set_control(
        stream: *mut pw_stream,
        id: u32,
        n_values: u32,
        values: *mut f32,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Query the time on the stream \\memberof pw_stream"]
    pub fn pw_stream_get_time(stream: *mut pw_stream, time: *mut pw_time) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a buffer that can be filled for playback streams or consumed"]
    #[doc = " for capture streams."]
    pub fn pw_stream_dequeue_buffer(stream: *mut pw_stream) -> *mut pw_buffer;
}
extern "C" {
    #[doc = " Submit a buffer for playback or recycle a buffer for capture."]
    pub fn pw_stream_queue_buffer(
        stream: *mut pw_stream,
        buffer: *mut pw_buffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Activate or deactivate the stream \\memberof pw_stream"]
    pub fn pw_stream_set_active(stream: *mut pw_stream, active: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Flush a stream. When \\a drain is true, the drained callback will"]
    #[doc = " be called when all data is played or recorded"]
    pub fn pw_stream_flush(stream: *mut pw_stream, drain: bool) -> ::std::os::raw::c_int;
}
#[doc = " \\class pw_filter"]
#[doc = ""]
#[doc = " \\brief PipeWire filter object class"]
#[doc = ""]
#[doc = " The filter object provides a convenient way to implement"]
#[doc = " processing filters."]
#[doc = ""]
#[doc = " See also \\ref page_filters and \\ref page_core_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_filter {
    _unused: [u8; 0],
}
pub const SPA_IO_Invalid: spa_io_type = 0;
#[doc = "< area to exchange buffers, struct spa_io_buffers"]
pub const SPA_IO_Buffers: spa_io_type = 1;
#[doc = "< expected byte range, struct spa_io_range"]
pub const SPA_IO_Range: spa_io_type = 2;
#[doc = "< area to update clock information, struct spa_io_clock"]
pub const SPA_IO_Clock: spa_io_type = 3;
#[doc = "< latency reporting, struct spa_io_latency"]
pub const SPA_IO_Latency: spa_io_type = 4;
#[doc = "< area for control messages, struct spa_io_sequence"]
pub const SPA_IO_Control: spa_io_type = 5;
#[doc = "< area for notify messages, struct spa_io_sequence"]
pub const SPA_IO_Notify: spa_io_type = 6;
#[doc = "< position information in the graph, struct spa_io_position"]
pub const SPA_IO_Position: spa_io_type = 7;
#[doc = "< rate matching between nodes, struct spa_io_rate_match"]
pub const SPA_IO_RateMatch: spa_io_type = 8;
#[doc = "< memory pointer, struct spa_io_memory"]
pub const SPA_IO_Memory: spa_io_type = 9;
#[doc = " Different IO area types"]
pub type spa_io_type = ::std::os::raw::c_uint;
#[doc = " IO area to exchange buffers."]
#[doc = ""]
#[doc = " A set of buffers should first be configured on the node/port."]
#[doc = " Further references to those buffers will be made by using the"]
#[doc = " id of the buffer."]
#[doc = ""]
#[doc = " If status is SPA_STATUS_OK, the host should ignore"]
#[doc = " the io area."]
#[doc = ""]
#[doc = " If status is SPA_STATUS_NEED_DATA, the host should:"]
#[doc = " 1) recycle the buffer in buffer_id, if possible"]
#[doc = " 2) prepare a new buffer and place the id in buffer_id."]
#[doc = ""]
#[doc = " If status is SPA_STATUS_HAVE_DATA, the host should consume"]
#[doc = " the buffer in buffer_id and set the state to"]
#[doc = " SPA_STATUS_NEED_DATA when new data is requested."]
#[doc = ""]
#[doc = " If status is SPA_STATUS_STOPPED, some error occurred on the"]
#[doc = " port."]
#[doc = ""]
#[doc = " If status is SPA_STATUS_DRAINED, data from the io area was"]
#[doc = " used to drain."]
#[doc = ""]
#[doc = " Status can also be a negative errno value to indicate errors."]
#[doc = " such as:"]
#[doc = " -EINVAL: buffer_id is invalid"]
#[doc = " -EPIPE: no more buffers available"]
#[repr(C)]
pub struct spa_io_buffers {
    #[doc = "< the status code"]
    pub status: i32,
    #[doc = "< a buffer id"]
    pub buffer_id: u32,
}
#[doc = " IO area to exchange a memory region"]
#[repr(C)]
pub struct spa_io_memory {
    #[doc = "< the status code"]
    pub status: i32,
    #[doc = "< the size of \\a data"]
    pub size: u32,
    #[doc = "< a memory pointer"]
    pub data: *mut ::std::os::raw::c_void,
}
#[doc = " A range, suitable for input ports that can suggest a range to output ports"]
#[repr(C)]
pub struct spa_io_range {
    #[doc = "< offset in range"]
    pub offset: u64,
    #[doc = "< minimum size of data"]
    pub min_size: u32,
    #[doc = "< maximum size of data"]
    pub max_size: u32,
}
#[doc = " Absolute time reporting."]
#[doc = ""]
#[doc = " Nodes that can report clocking information will receive this io block."]
#[doc = " The application sets the id. This is usually set as part of the"]
#[doc = " position information but can also be set separately."]
#[doc = ""]
#[doc = " The clock counts the elapsed time according to the clock provider"]
#[doc = " since the provider was last started."]
#[repr(C)]
pub struct spa_io_clock {
    #[doc = "< clock flags"]
    pub flags: u32,
    #[doc = "< unique clock id, set by application"]
    pub id: u32,
    #[doc = "< clock name prefixed with API, set by node. The clock name"]
    #[doc = "  is unique per clock and can be used to check if nodes"]
    #[doc = "  share the same clock."]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< time in nanoseconds against monotonic clock"]
    pub nsec: u64,
    #[doc = "< rate for position/duration/delay"]
    pub rate: spa_fraction,
    #[doc = "< current position"]
    pub position: u64,
    #[doc = "< duration of current cycle"]
    pub duration: u64,
    #[doc = "< delay between position and hardware,"]
    #[doc = "  positive for capture, negative for playback"]
    pub delay: i64,
    #[doc = "< rate difference between clock and monotonic time"]
    pub rate_diff: f64,
    #[doc = "< extimated next wakeup time in nanoseconds"]
    pub next_nsec: u64,
    pub padding: [u32; 8usize],
}
#[repr(C)]
pub struct spa_io_video_size {
    #[doc = "< optional flags"]
    pub flags: u32,
    #[doc = "< video stride in bytes"]
    pub stride: u32,
    #[doc = "< the video size"]
    pub size: spa_rectangle,
    #[doc = "< the minimum framerate, the cycle duration is"]
    #[doc = "  always smaller to ensure there is only one"]
    #[doc = "  video frame per cycle."]
    pub framerate: spa_fraction,
    pub padding: [u32; 4usize],
}
#[doc = " latency reporting"]
#[repr(C)]
pub struct spa_io_latency {
    #[doc = "< rate for min/max"]
    pub rate: spa_fraction,
    #[doc = "< min latency"]
    pub min: u64,
    #[doc = "< max latency"]
    pub max: u64,
}
#[doc = " control stream, io area for SPA_IO_Control and SPA_IO_Notify"]
#[repr(C)]
pub struct spa_io_sequence {
    #[doc = "< sequence of timed events"]
    pub sequence: spa_pod_sequence,
}
#[doc = " bar and beat segment"]
#[repr(C)]
pub struct spa_io_segment_bar {
    #[doc = "< extra flags"]
    pub flags: u32,
    #[doc = "< offset in segment of this beat"]
    pub offset: u32,
    #[doc = "< time signature numerator"]
    pub signature_num: f32,
    #[doc = "< time signature denominator"]
    pub signature_denom: f32,
    #[doc = "< beats per minute"]
    pub bpm: f64,
    #[doc = "< current beat in segment"]
    pub beat: f64,
    pub padding: [u32; 8usize],
}
#[doc = " video frame segment"]
#[repr(C)]
pub struct spa_io_segment_video {
    #[doc = "< flags"]
    pub flags: u32,
    #[doc = "< offset in segment"]
    pub offset: u32,
    pub framerate: spa_fraction,
    pub hours: u32,
    pub minutes: u32,
    pub seconds: u32,
    pub frames: u32,
    #[doc = "< 0 for progressive, 1 and 2 for interlaced"]
    pub field_count: u32,
    pub padding: [u32; 11usize],
}
#[doc = " A segment converts a running time to a segment (stream) position."]
#[doc = ""]
#[doc = " The segment position is valid when the current running time is between"]
#[doc = " start and start + duration. The position is then"]
#[doc = " calculated as:"]
#[doc = ""]
#[doc = "   (running time - start) * rate + position;"]
#[doc = ""]
#[doc = " Support for looping is done by specifying the LOOPING flags with a"]
#[doc = " non-zero duration. When the running time reaches start + duration,"]
#[doc = " duration is added to start and the loop repeats."]
#[doc = ""]
#[doc = " Care has to be taken when the running time + clock.duration extends"]
#[doc = " past the start + duration from the segment; the user should correctly"]
#[doc = " wrap around and partially repeat the loop in the current cycle."]
#[doc = ""]
#[doc = " Extra information can be placed in the segment by setting the valid flags"]
#[doc = " and filling up the corresponding structures."]
#[repr(C)]
pub struct spa_io_segment {
    pub version: u32,
    #[doc = "< extra flags"]
    pub flags: u32,
    #[doc = "< value of running time when this"]
    #[doc = "  info is active. Can be in the future for"]
    #[doc = "  pending changes. It does not have to be in"]
    #[doc = "  exact multiples of the clock duration."]
    pub start: u64,
    #[doc = "< duration when this info becomes invalid expressed"]
    #[doc = "  in running time. If the duration is 0, this"]
    #[doc = "  segment extends to the next segment. If the"]
    #[doc = "  segment becomes invalid and the looping flag is"]
    #[doc = "  set, the segment repeats."]
    pub duration: u64,
    #[doc = "< overal rate of the segment, can be negative for"]
    #[doc = "  backwards time reporting."]
    pub rate: f64,
    #[doc = "< The position when the running time == start."]
    #[doc = "  can be invalid when the owner of the extra segment"]
    #[doc = "  information has not yet made the mapping."]
    pub position: u64,
    pub bar: spa_io_segment_bar,
    pub video: spa_io_segment_video,
}
pub const SPA_IO_POSITION_STATE_STOPPED: spa_io_position_state = 0;
pub const SPA_IO_POSITION_STATE_STARTING: spa_io_position_state = 1;
pub const SPA_IO_POSITION_STATE_RUNNING: spa_io_position_state = 2;
pub type spa_io_position_state = ::std::os::raw::c_uint;
#[doc = " The position information adds extra meaning to the raw clock times."]
#[doc = ""]
#[doc = " It is set on all nodes and the clock id will contain the clock of the"]
#[doc = " driving node in the graph."]
#[doc = ""]
#[doc = " The position information contains 1 or more segments that convert the"]
#[doc = " raw clock times to a stream time. They are sorted based on their"]
#[doc = " start times, and thus the order in which they will activate in"]
#[doc = " the future. This makes it possible to look ahead in the scheduled"]
#[doc = " segments and anticipate the changes in the timeline."]
#[repr(C)]
pub struct spa_io_position {
    #[doc = "< clock position of driver, always valid and"]
    #[doc = "  read only"]
    pub clock: spa_io_clock,
    #[doc = "< size of the video in the current cycle"]
    pub video: spa_io_video_size,
    #[doc = "< an offset to subtract from the clock position"]
    #[doc = "  to get a running time. This is the time that"]
    #[doc = "  the state has been in the RUNNING state and the"]
    #[doc = "  time that should be used to compare the segment"]
    #[doc = "  start values against."]
    pub offset: i64,
    #[doc = "< one of enum spa_io_position_state"]
    pub state: u32,
    #[doc = "< number of segments"]
    pub n_segments: u32,
    #[doc = "< segments"]
    pub segments: [spa_io_segment; 8usize],
}
#[doc = " rate matching"]
#[repr(C)]
pub struct spa_io_rate_match {
    #[doc = "< extra delay in samples for resampler"]
    pub delay: u32,
    #[doc = "< requested input size for resampler"]
    pub size: u32,
    #[doc = "< rate for resampler"]
    pub rate: f64,
    #[doc = "< extra flags"]
    pub flags: u32,
    pub padding: [u32; 7usize],
}
#[doc = "< the strean is in error"]
pub const PW_FILTER_STATE_ERROR: pw_filter_state = -1;
#[doc = "< unconnected"]
pub const PW_FILTER_STATE_UNCONNECTED: pw_filter_state = 0;
#[doc = "< connection is in progress"]
pub const PW_FILTER_STATE_CONNECTING: pw_filter_state = 1;
#[doc = "< filter is connected and paused"]
pub const PW_FILTER_STATE_PAUSED: pw_filter_state = 2;
#[doc = "< filter is streaming"]
pub const PW_FILTER_STATE_STREAMING: pw_filter_state = 3;
#[doc = " \\enum pw_filter_state The state of a filter \\memberof pw_filter"]
pub type pw_filter_state = ::std::os::raw::c_int;
#[doc = " Events for a filter. These events are always called from the mainloop"]
#[doc = " unless explicitly documented otherwise."]
#[repr(C)]
pub struct pw_filter_events {
    pub version: u32,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " when the filter state changes"]
    pub state_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            old: pw_filter_state,
            state: pw_filter_state,
            error: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " when io changed on a port of the filter (when port_data is NULL)."]
    pub io_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            port_data: *mut ::std::os::raw::c_void,
            id: u32,
            area: *mut ::std::os::raw::c_void,
            size: u32,
        ),
    >,
    #[doc = " when a parameter changed on a port of the filter (when port_data is NULL)."]
    pub param_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            port_data: *mut ::std::os::raw::c_void,
            id: u32,
            param: *const spa_pod,
        ),
    >,
    #[doc = " when a new buffer was created for a port"]
    pub add_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            port_data: *mut ::std::os::raw::c_void,
            buffer: *mut pw_buffer,
        ),
    >,
    #[doc = " when a buffer was destroyed for a port"]
    pub remove_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            port_data: *mut ::std::os::raw::c_void,
            buffer: *mut pw_buffer,
        ),
    >,
    #[doc = " do processing. This is normally called from the"]
    #[doc = "  mainloop but can also be called directly from the realtime data"]
    #[doc = "  thread if the user is prepared to deal with this."]
    pub process: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, position: *mut spa_io_position),
    >,
    #[doc = " The filter is drained"]
    pub drained: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
extern "C" {
    #[doc = " Convert a filter state to a readable string \\memberof pw_filter"]
    pub fn pw_filter_state_as_string(state: pw_filter_state) -> *const ::std::os::raw::c_char;
}
#[doc = "< no flags"]
pub const PW_FILTER_FLAG_NONE: pw_filter_flags = 0;
#[doc = "< start the filter inactive,"]
#[doc = "  pw_filter_set_active() needs to be"]
#[doc = "  called explicitly"]
pub const PW_FILTER_FLAG_INACTIVE: pw_filter_flags = 1;
#[doc = "< be a driver"]
pub const PW_FILTER_FLAG_DRIVER: pw_filter_flags = 2;
#[doc = "< call process from the realtime"]
#[doc = "  thread"]
pub const PW_FILTER_FLAG_RT_PROCESS: pw_filter_flags = 4;
#[doc = " \\enum pw_filter_flags Extra flags that can be used in \\ref pw_filter_connect() \\memberof pw_filter"]
pub type pw_filter_flags = ::std::os::raw::c_uint;
#[doc = "< no flags"]
pub const PW_FILTER_PORT_FLAG_NONE: pw_filter_port_flags = 0;
#[doc = "< mmap the buffers except DmaBuf"]
pub const PW_FILTER_PORT_FLAG_MAP_BUFFERS: pw_filter_port_flags = 1;
#[doc = "< the application will allocate buffer"]
#[doc = "  memory. In the add_buffer event, the"]
#[doc = "  data of the buffer should be set"]
pub const PW_FILTER_PORT_FLAG_ALLOC_BUFFERS: pw_filter_port_flags = 2;
pub type pw_filter_port_flags = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Create a new unconneced \\ref pw_filter \\memberof pw_filter"]
    #[doc = " \\return a newly allocated \\ref pw_filter"]
    pub fn pw_filter_new(
        core: *mut pw_core,
        name: *const ::std::os::raw::c_char,
        props: *mut pw_properties,
    ) -> *mut pw_filter;
}
extern "C" {
    pub fn pw_filter_new_simple(
        loop_: *mut pw_loop,
        name: *const ::std::os::raw::c_char,
        props: *mut pw_properties,
        events: *const pw_filter_events,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut pw_filter;
}
extern "C" {
    #[doc = " Destroy a filter \\memberof pw_filter"]
    pub fn pw_filter_destroy(filter: *mut pw_filter);
}
extern "C" {
    pub fn pw_filter_add_listener(
        filter: *mut pw_filter,
        listener: *mut spa_hook,
        events: *const pw_filter_events,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pw_filter_get_state(
        filter: *mut pw_filter,
        error: *mut *const ::std::os::raw::c_char,
    ) -> pw_filter_state;
}
extern "C" {
    pub fn pw_filter_get_name(filter: *mut pw_filter) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pw_filter_get_core(filter: *mut pw_filter) -> *mut pw_core;
}
extern "C" {
    #[doc = " Connect a filter for processing. \\memberof pw_filter"]
    #[doc = " \\return 0 on success < 0 on error."]
    #[doc = ""]
    #[doc = " You should connect to the process event and use pw_filter_dequeue_buffer()"]
    #[doc = " to get the latest metadata and data."]
    pub fn pw_filter_connect(
        filter: *mut pw_filter,
        flags: pw_filter_flags,
        params: *mut *const spa_pod,
        n_params: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the node ID of the filter. \\memberof pw_filter"]
    #[doc = " \\return node ID."]
    pub fn pw_filter_get_node_id(filter: *mut pw_filter) -> u32;
}
extern "C" {
    #[doc = " Disconnect \\a filter \\memberof pw_filter"]
    pub fn pw_filter_disconnect(filter: *mut pw_filter) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " add a port to the filter, returns user data of port_data_size."]
    pub fn pw_filter_add_port(
        filter: *mut pw_filter,
        direction: spa_direction,
        flags: pw_filter_port_flags,
        port_data_size: usize,
        props: *mut pw_properties,
        params: *mut *const spa_pod,
        n_params: u32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " remove a port from the filter"]
    pub fn pw_filter_remove_port(port_data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get properties, port_data of NULL will give global properties"]
    pub fn pw_filter_get_properties(
        filter: *mut pw_filter,
        port_data: *mut ::std::os::raw::c_void,
    ) -> *const pw_properties;
}
extern "C" {
    #[doc = " Update properties, use NULL port_data for global filter properties"]
    pub fn pw_filter_update_properties(
        filter: *mut pw_filter,
        port_data: *mut ::std::os::raw::c_void,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the filter in error state"]
    pub fn pw_filter_set_error(
        filter: *mut pw_filter,
        res: ::std::os::raw::c_int,
        error: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Update params, use NULL port_data for global filter params"]
    pub fn pw_filter_update_params(
        filter: *mut pw_filter,
        port_data: *mut ::std::os::raw::c_void,
        params: *mut *const spa_pod,
        n_params: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Query the time on the filter \\memberof pw_filter"]
    pub fn pw_filter_get_time(filter: *mut pw_filter, time: *mut pw_time) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a buffer that can be filled for output ports or consumed"]
    #[doc = " for input ports."]
    pub fn pw_filter_dequeue_buffer(port_data: *mut ::std::os::raw::c_void) -> *mut pw_buffer;
}
extern "C" {
    #[doc = " Submit a buffer for playback or recycle a buffer for capture."]
    pub fn pw_filter_queue_buffer(
        port_data: *mut ::std::os::raw::c_void,
        buffer: *mut pw_buffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a data pointer to the buffer data"]
    pub fn pw_filter_get_dsp_buffer(
        port_data: *mut ::std::os::raw::c_void,
        n_samples: u32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Activate or deactivate the filter \\memberof pw_filter"]
    pub fn pw_filter_set_active(filter: *mut pw_filter, active: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Flush a filter. When \\a drain is true, the drained callback will"]
    #[doc = " be called when all data is played or recorded"]
    pub fn pw_filter_flush(filter: *mut pw_filter, drain: bool) -> ::std::os::raw::c_int;
}
#[doc = " \\page page_thread_loop Threaded Loop"]
#[doc = ""]
#[doc = " \\section sec_thread_loop_overview Overview"]
#[doc = ""]
#[doc = " The threaded loop implementation is a special wrapper around the"]
#[doc = " regular \\ref pw_loop implementation."]
#[doc = ""]
#[doc = " The added feature in the threaded loop is that it spawns a new thread"]
#[doc = " that runs the wrapped loop. This allows a synchronous application to use"]
#[doc = " the asynchronous API without risking to stall the PipeWire library."]
#[doc = ""]
#[doc = " \\section sec_thread_loop_create Creation"]
#[doc = ""]
#[doc = " A \\ref pw_thread_loop object is created using pw_thread_loop_new()."]
#[doc = " The \\ref pw_loop to wrap must be given as an argument along with the name"]
#[doc = " for the thread that will be spawned."]
#[doc = ""]
#[doc = " After allocating the object, the thread must be started with"]
#[doc = " pw_thread_loop_start()"]
#[doc = ""]
#[doc = " \\section sec_thread_loop_destruction Destruction"]
#[doc = ""]
#[doc = " When the PipeWire connection has been terminated, the thread must be"]
#[doc = " stopped and the resources freed. Stopping the thread is done using"]
#[doc = " pw_thread_loop_stop(), which must be called without the lock (see"]
#[doc = " below) held. When that function returns, the thread is stopped and the"]
#[doc = " \\ref pw_thread_loop object can be freed using pw_thread_loop_destroy()."]
#[doc = ""]
#[doc = " \\section sec_thread_loop_locking Locking"]
#[doc = ""]
#[doc = " Since the PipeWire API doesn't allow concurrent accesses to objects,"]
#[doc = " a locking scheme must be used to guarantee safe usage. The threaded"]
#[doc = " loop API provides such a scheme through the functions"]
#[doc = " pw_thread_loop_lock() and pw_thread_loop_unlock()."]
#[doc = ""]
#[doc = " The lock is recursive, so it's safe to use it multiple times from the same"]
#[doc = " thread. Just make sure you call pw_thread_loop_unlock() the same"]
#[doc = " number of times you called pw_thread_loop_lock()."]
#[doc = ""]
#[doc = " The lock needs to be held whenever you call any PipeWire function that"]
#[doc = " uses an object associated with this loop. Make sure you do not hold"]
#[doc = " on to the lock more than necessary though, as the threaded loop stops"]
#[doc = " while the lock is held."]
#[doc = ""]
#[doc = " \\section sec_thread_loop_events Events and Callbacks"]
#[doc = ""]
#[doc = " All events and callbacks are called with the thread lock held."]
#[doc = ""]
#[doc = ""]
#[doc = " \\brief PipeWire threaded loop object"]
#[doc = ""]
#[doc = " The threaded loop object runs a \\ref pw_loop in a separate thread"]
#[doc = " and ensures proper locking is done."]
#[doc = ""]
#[doc = " All of the loop callbacks will be executed with the loop"]
#[doc = " lock held."]
#[doc = ""]
#[doc = " See also \\ref page_thread_loop"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_thread_loop {
    _unused: [u8; 0],
}
#[doc = " Thread loop events"]
#[repr(C)]
pub struct pw_thread_loop_events {
    pub version: u32,
    #[doc = " the loop is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
extern "C" {
    #[doc = " Make a new thread loop with the given name and optional properties."]
    pub fn pw_thread_loop_new(
        name: *const ::std::os::raw::c_char,
        props: *const spa_dict,
    ) -> *mut pw_thread_loop;
}
extern "C" {
    #[doc = " Make a new thread loop with the given loop, name and optional properties."]
    #[doc = " When \\a loop is NULL, a new loop will be created."]
    pub fn pw_thread_loop_new_full(
        loop_: *mut pw_loop,
        name: *const ::std::os::raw::c_char,
        props: *const spa_dict,
    ) -> *mut pw_thread_loop;
}
extern "C" {
    #[doc = " Destroy a thread loop"]
    pub fn pw_thread_loop_destroy(loop_: *mut pw_thread_loop);
}
extern "C" {
    #[doc = " Add an event listener"]
    pub fn pw_thread_loop_add_listener(
        loop_: *mut pw_thread_loop,
        listener: *mut spa_hook,
        events: *const pw_thread_loop_events,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Get the loop implementation of the thread loop"]
    pub fn pw_thread_loop_get_loop(loop_: *mut pw_thread_loop) -> *mut pw_loop;
}
extern "C" {
    #[doc = " Start the thread loop"]
    pub fn pw_thread_loop_start(loop_: *mut pw_thread_loop) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop the thread loop"]
    pub fn pw_thread_loop_stop(loop_: *mut pw_thread_loop);
}
extern "C" {
    #[doc = " Lock the loop. This ensures exclusive ownership of the loop"]
    pub fn pw_thread_loop_lock(loop_: *mut pw_thread_loop);
}
extern "C" {
    #[doc = " Unlock the loop"]
    pub fn pw_thread_loop_unlock(loop_: *mut pw_thread_loop);
}
extern "C" {
    #[doc = " Release the lock and wait until some thread calls \\ref pw_thread_loop_signal"]
    pub fn pw_thread_loop_wait(loop_: *mut pw_thread_loop);
}
extern "C" {
    #[doc = " Release the lock and wait a maximum of 'wait_max_sec' seconds"]
    #[doc = "  until some thread calls \\ref pw_thread_loop_signal or time out"]
    pub fn pw_thread_loop_timed_wait(
        loop_: *mut pw_thread_loop,
        wait_max_sec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a struct timespec suitable for \\ref pw_thread_loop_timed_wait_full."]
    #[doc = " Since: 0.3.7"]
    pub fn pw_thread_loop_get_time(
        loop_: *mut pw_thread_loop,
        abstime: *mut timespec,
        timeout: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release the lock and wait up to \\a abstime until some thread calls"]
    #[doc = " \\ref pw_thread_loop_signal. Use \\ref pw_thread_loop_get_time to make a timeout."]
    #[doc = " Since: 0.3.7"]
    pub fn pw_thread_loop_timed_wait_full(
        loop_: *mut pw_thread_loop,
        abstime: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Signal all threads waiting with \\ref pw_thread_loop_wait"]
    pub fn pw_thread_loop_signal(loop_: *mut pw_thread_loop, wait_for_accept: bool);
}
extern "C" {
    #[doc = " Signal all threads executing \\ref pw_thread_loop_signal with wait_for_accept"]
    pub fn pw_thread_loop_accept(loop_: *mut pw_thread_loop);
}
extern "C" {
    #[doc = " Check if inside the thread"]
    pub fn pw_thread_loop_in_thread(loop_: *mut pw_thread_loop) -> bool;
}
#[doc = " \\class pw_data_loop"]
#[doc = ""]
#[doc = " PipeWire rt-loop object. This loop starts a new real-time thread that"]
#[doc = " is designed to run the processing graph."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_data_loop {
    _unused: [u8; 0],
}
#[doc = " Loop events, use \\ref pw_data_loop_add_listener to add a listener"]
#[repr(C)]
pub struct pw_data_loop_events {
    pub version: u32,
    #[doc = " The loop is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
extern "C" {
    #[doc = " Make a new loop."]
    pub fn pw_data_loop_new(props: *const spa_dict) -> *mut pw_data_loop;
}
extern "C" {
    #[doc = " Add an event listener to loop"]
    pub fn pw_data_loop_add_listener(
        loop_: *mut pw_data_loop,
        listener: *mut spa_hook,
        events: *const pw_data_loop_events,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " wait for activity on the loop up to \\a timeout milliseconds."]
    #[doc = " Should be called from the loop function"]
    pub fn pw_data_loop_wait(
        loop_: *mut pw_data_loop,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " make sure the thread will exit. Can be called from a loop callback"]
    pub fn pw_data_loop_exit(loop_: *mut pw_data_loop);
}
extern "C" {
    #[doc = " Get the loop implementation of this data loop"]
    pub fn pw_data_loop_get_loop(loop_: *mut pw_data_loop) -> *mut pw_loop;
}
extern "C" {
    #[doc = " Destroy the loop"]
    pub fn pw_data_loop_destroy(loop_: *mut pw_data_loop);
}
extern "C" {
    #[doc = " Start the processing thread"]
    pub fn pw_data_loop_start(loop_: *mut pw_data_loop) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop the processing thread"]
    pub fn pw_data_loop_stop(loop_: *mut pw_data_loop) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the current thread is the processing thread"]
    pub fn pw_data_loop_in_thread(loop_: *mut pw_data_loop) -> bool;
}
extern "C" {
    #[doc = " invoke func in the context of the thread or in the caller thread when"]
    #[doc = " the loop is not running. Since 0.3.3"]
    pub fn pw_data_loop_invoke(
        loop_: *mut pw_data_loop,
        func: spa_invoke_func_t,
        seq: u32,
        data: *const ::std::os::raw::c_void,
        size: usize,
        block: bool,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pw_type_info() -> *const spa_type_info;
}
extern "C" {
    #[doc = " Return the version of the library the current application is"]
    #[doc = " linked to."]
    pub fn pw_get_library_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\class pw_pipewire"]
    #[doc = ""]
    #[doc = " \\brief PipeWire initialization and infrastructure functions"]
    pub fn pw_init(argc: *mut ::std::os::raw::c_int, argv: *mut *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn pw_deinit();
}
extern "C" {
    pub fn pw_debug_is_category_enabled(name: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn pw_get_application_name() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pw_get_prgname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pw_get_user_name() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pw_get_host_name() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pw_get_client_name() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pw_in_valgrind() -> bool;
}
extern "C" {
    pub fn pw_direction_reverse(direction: spa_direction) -> spa_direction;
}
extern "C" {
    pub fn pw_get_support(support: *mut spa_support, max_support: u32) -> u32;
}
extern "C" {
    pub fn pw_load_spa_handle(
        lib: *const ::std::os::raw::c_char,
        factory_name: *const ::std::os::raw::c_char,
        info: *const spa_dict,
        n_support: u32,
        support: *const spa_support,
    ) -> *mut spa_handle;
}
extern "C" {
    pub fn pw_unload_spa_handle(handle: *mut spa_handle) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_core {
    pub _address: u8,
}
